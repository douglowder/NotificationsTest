diff --git a/node_modules/expo-notifications/expo-module.config.json b/node_modules/expo-notifications/expo-module.config.json
index a335999..688c0f0 100644
--- a/node_modules/expo-notifications/expo-module.config.json
+++ b/node_modules/expo-notifications/expo-module.config.json
@@ -4,6 +4,8 @@
     "modules": [
       "BadgeModule",
       "CategoriesModule",
+      "HandlerModule",
+      "EmitterModule",
       "PresentationModule",
       "PushTokenModule",
       "ServerRegistrationModule",
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.h
index 14e35d3..12a72cb 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.h
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.h
@@ -6,10 +6,10 @@ NS_ASSUME_NONNULL_BEGIN
 
 @interface EXNotificationSerializer : NSObject
 
-+ (NSDictionary *)serializedNotification:(UNNotification *)notification;
-+ (NSDictionary *)serializedNotificationRequest:(UNNotificationRequest *)notificationRequest;
-+ (NSDictionary *)serializedNotificationResponse:(UNNotificationResponse *)notificationResponse;
-+ (NSDictionary *)serializedNotificationContent:(UNNotificationRequest *)request;
++ (NSDictionary<NSString *, NSObject *> *)serializedNotification:(UNNotification *)notification;
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationRequest:(UNNotificationRequest *)notificationRequest;
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationResponse:(UNNotificationResponse *)notificationResponse;
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationContent:(UNNotificationRequest *)request;
 
 @end
 
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.m
index 1c5bdd0..5f6d83a 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.m
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.m
@@ -9,7 +9,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
 
 @implementation EXNotificationSerializer
 
-+ (NSDictionary *)serializedNotificationResponse:(UNNotificationResponse *)response
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationResponse:(UNNotificationResponse *)response
 {
   NSMutableDictionary *serializedResponse = [NSMutableDictionary dictionary];
   NSString *actionIdentifier = response.actionIdentifier;
@@ -25,7 +25,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return serializedResponse;
 }
 
-+ (NSDictionary *)serializedNotification:(UNNotification *)notification
++ (NSDictionary<NSString *, NSObject *> *)serializedNotification:(UNNotification *)notification
 {
   NSMutableDictionary *serializedNotification = [NSMutableDictionary dictionary];
   serializedNotification[@"request"] = [self serializedNotificationRequest:notification.request];
@@ -33,7 +33,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return serializedNotification;
 }
 
-+ (NSDictionary *)serializedNotificationRequest:(UNNotificationRequest *)request
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationRequest:(UNNotificationRequest *)request
 {
   NSMutableDictionary *serializedRequest = [NSMutableDictionary dictionary];
   serializedRequest[@"identifier"] = request.identifier;
@@ -42,7 +42,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return serializedRequest;
 }
 
-+ (NSDictionary *)serializedNotificationContent:(UNNotificationRequest *)request
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationContent:(UNNotificationRequest *)request
 {
   UNNotificationContent *content = request.content;
   NSMutableDictionary *serializedContent = [NSMutableDictionary dictionary];
@@ -76,7 +76,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return [interruptionLevelMap objectForKey:@(interruptionLevel)];
 }
 
-+ (NSDictionary *)serializedNotificationData:(UNNotificationRequest *)request
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationData:(UNNotificationRequest *)request
 {
   BOOL isRemote = [request.trigger isKindOfClass:[UNPushNotificationTrigger class]];
   return isRemote ? request.content.userInfo[@"body"] : request.content.userInfo;
@@ -109,7 +109,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return serializedAttachments;
 }
 
-+ (NSDictionary *)serializedNotificationAttachment:(UNNotificationAttachment *)attachment
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationAttachment:(UNNotificationAttachment *)attachment
 {
   NSMutableDictionary *serializedAttachment = [NSMutableDictionary dictionary];
   serializedAttachment[@"identifier"] = attachment.identifier ?: [NSNull null];
@@ -118,7 +118,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return serializedAttachment;
 }
 
-+ (NSDictionary *)serializedNotificationTrigger:(UNNotificationRequest *)request
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationTrigger:(UNNotificationRequest *)request
 {
   UNNotificationTrigger *trigger = request.trigger;
   NSMutableDictionary *serializedTrigger = [NSMutableDictionary dictionary];
@@ -149,7 +149,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return serializedTrigger;
 }
 
-+ (NSDictionary *)serializedDateComponents:(NSDateComponents *)dateComponents
++ (NSDictionary<NSString *, NSObject *> *)serializedDateComponents:(NSDateComponents *)dateComponents
 {
   NSMutableDictionary *serializedComponents = [NSMutableDictionary dictionary];
   NSArray<NSNumber *> *autoConvertedUnits = [[self calendarUnitsConversionMap] allKeys];
@@ -197,7 +197,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return [self calendarUnitsConversionMap][@(calendarUnit)];
 }
 
-+ (NSDictionary *)serializedRegion:(CLRegion *)region
++ (NSDictionary<NSString *, NSObject *> *)serializedRegion:(CLRegion *)region
 {
   NSMutableDictionary *serializedRegion = [NSMutableDictionary dictionary];
   serializedRegion[@"identifier"] = region.identifier;
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EXNotificationsEmitter.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EXNotificationsEmitter.h
deleted file mode 100644
index 3590bf1..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EXNotificationsEmitter.h
+++ /dev/null
@@ -1,18 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-#import <ExpoModulesCore/EXEventEmitter.h>
-#import <ExpoModulesCore/EXModuleRegistryConsumer.h>
-#import <ExpoModulesCore/EXEventEmitterService.h>
-
-#import <EXNotifications/EXNotificationsDelegate.h>
-
-static NSString * const onDidReceiveNotification = @"onDidReceiveNotification";
-static NSString * const onDidReceiveNotificationResponse = @"onDidReceiveNotificationResponse";
-static NSString * const onDidClearNotificationResponse = @"onDidClearNotificationResponse";
-
-@interface EXNotificationsEmitter : EXExportedModule <EXEventEmitter, EXModuleRegistryConsumer, EXNotificationsDelegate>
-
-@property (nonatomic, weak, readonly) id<EXEventEmitterService> eventEmitter;
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EXNotificationsEmitter.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EXNotificationsEmitter.m
deleted file mode 100644
index 7d46d62..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EXNotificationsEmitter.m
+++ /dev/null
@@ -1,120 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXNotificationsEmitter.h>
-#import <EXNotifications/EXNotificationSerializer.h>
-#import <EXNotifications/EXNotificationCenterDelegate.h>
-
-#import <ExpoModulesCore/EXEventEmitterService.h>
-
-@interface EXNotificationsEmitter ()
-
-@property (nonatomic, weak) id<EXNotificationCenterDelegate> notificationCenterDelegate;
-
-@property (nonatomic, assign) BOOL isBeingObserved;
-@property (nonatomic, assign) BOOL isListening;
-
-@property (nonatomic, weak) id<EXEventEmitterService> eventEmitter;
-
-@end
-
-@implementation EXNotificationsEmitter
-
-EX_EXPORT_MODULE(ExpoNotificationsEmitter);
-
-EX_EXPORT_METHOD_AS(getLastNotificationResponseAsync,
-                    getLastNotificationResponseAsyncWithResolver:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject)
-{
-  UNNotificationResponse* lastResponse = _notificationCenterDelegate.lastNotificationResponse;
-  resolve(lastResponse ? [self serializedNotificationResponse:lastResponse] : [NSNull null]);
-}
-
-EX_EXPORT_METHOD_AS(clearLastNotificationResponseAsync,
-                    clearLastNotificationResponseAsyncWithResolver:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject)
-{
-  _notificationCenterDelegate.lastNotificationResponse = nil;
-  resolve([NSNull null]);
-}
-
-# pragma mark - EXModuleRegistryConsumer
-
-- (void)setModuleRegistry:(EXModuleRegistry *)moduleRegistry
-{
-  _eventEmitter = [moduleRegistry getModuleImplementingProtocol:@protocol(EXEventEmitterService)];
-  _notificationCenterDelegate = [moduleRegistry getSingletonModuleForName:@"NotificationCenterDelegate"];
-}
-
-# pragma mark - EXEventEmitter
-
-- (NSArray<NSString *> *)supportedEvents
-{
-  return @[onDidReceiveNotification, onDidReceiveNotificationResponse, onDidClearNotificationResponse];
-}
-
-- (void)startObserving
-{
-  [self setIsBeingObserved:YES];
-}
-
-- (void)stopObserving
-{
-  [self setIsBeingObserved:NO];
-}
-
-- (void)setIsBeingObserved:(BOOL)isBeingObserved
-{
-  _isBeingObserved = isBeingObserved;
-  BOOL shouldListen = _isBeingObserved;
-  if (shouldListen && !_isListening) {
-    [_notificationCenterDelegate addDelegate:self];
-    _isListening = YES;
-  } else if (!shouldListen && _isListening) {
-    [_notificationCenterDelegate removeDelegate:self];
-    _isListening = NO;
-  }
-}
-
-# pragma mark - EXNotificationsDelegate
-
-- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
-{
-  // Background task execution would happen here.
-  completionHandler(UIBackgroundFetchResultNoData);
-}
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler
-{
-  _notificationCenterDelegate.lastNotificationResponse = response;
-  [self sendEventWithName:onDidReceiveNotificationResponse body:[self serializedNotificationResponse:response]];
-  completionHandler();
-}
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler
-{
-  [self sendEventWithName:onDidReceiveNotification body:[self serializedNotification:notification]];
-  completionHandler(UNNotificationPresentationOptionNone);
-}
-
-- (void)sendEventWithName:(NSString *)eventName body:(id)body
-{
-  // Silence React Native warning: "Sending ... with no listeners registered."
-  // See: https://github.com/expo/expo/pull/10883#pullrequestreview-529183413
-  // While in practice we don't need to verify this, as as of the end of 2020
-  // we wouldn't send any event to JS if we weren't being observed because
-  // we wouldn't be subscribed to the notification center delegate it's nice
-  // to be sure this problem won't ever arise.
-  if (_isBeingObserved) {
-    [_eventEmitter sendEventWithName:eventName body:body];
-  }
-}
-
-- (NSDictionary *)serializedNotification:(UNNotification *)notification
-{
-  return [EXNotificationSerializer serializedNotification:notification];
-}
-
-- (NSDictionary *)serializedNotificationResponse:(UNNotificationResponse *)notificationResponse
-{
-  return [EXNotificationSerializer serializedNotificationResponse:notificationResponse];
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EmitterModule.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EmitterModule.swift
new file mode 100644
index 0000000..4aadb02
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EmitterModule.swift
@@ -0,0 +1,50 @@
+//  Copyright © 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+let onDidReceiveNotification = "onDidReceiveNotification"
+let onDidReceiveNotificationResponse = "onDidReceiveNotificationResponse"
+let onDidClearNotificationResponse = "onDidClearNotificationResponse"
+
+public class EmitterModule: Module, NotificationDelegate {
+  var presentedNotifications: Set<String> = []
+
+  public func definition() -> ModuleDefinition {
+    Name("ExpoNotificationsEmitter")
+
+    Events([onDidReceiveNotification, onDidReceiveNotificationResponse, onDidClearNotificationResponse])
+
+    OnStartObserving {
+      NotificationCenterManager.shared.addDelegate(self)
+    }
+
+    OnStopObserving {
+      NotificationCenterManager.shared.removeDelegate(self)
+    }
+  }
+
+  /*
+   TODO: background processing
+
+   - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
+   {
+     // Background task execution would happen here.
+     completionHandler(UIBackgroundFetchResultNoData);
+   }
+   */
+  
+  public func didReceive(_ response: UNNotificationResponse, completionHandler: @escaping () -> Void) -> Bool {
+    NotificationCenterManager.shared.lastResponse = response
+    let serializedResponse = EXNotificationSerializer.serializedNotificationResponse(response)
+    self.sendEvent(onDidReceiveNotificationResponse, serializedResponse as [String: Any])
+    return true
+  }
+
+  public func willPresent(_ notification: UNNotification, completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) -> Bool {
+    let serializedNotification = EXNotificationSerializer.serializedNotification(notification)
+    self.sendEvent(onDidReceiveNotification, serializedNotification as [String: Any])
+    return true
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXNotificationsHandlerModule.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXNotificationsHandlerModule.h
deleted file mode 100644
index a8536c0..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXNotificationsHandlerModule.h
+++ /dev/null
@@ -1,12 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-#import <ExpoModulesCore/EXEventEmitter.h>
-#import <ExpoModulesCore/EXModuleRegistryConsumer.h>
-
-#import <EXNotifications/EXNotificationsDelegate.h>
-#import <EXNotifications/EXSingleNotificationHandlerTask.h>
-
-@interface EXNotificationsHandlerModule : EXExportedModule <EXEventEmitter, EXModuleRegistryConsumer, EXNotificationsDelegate, EXSingleNotificationHandlerTaskDelegate>
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXNotificationsHandlerModule.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXNotificationsHandlerModule.m
deleted file mode 100644
index e20e6e8..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXNotificationsHandlerModule.m
+++ /dev/null
@@ -1,109 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXNotificationsHandlerModule.h>
-#import <EXNotifications/EXNotificationSerializer.h>
-#import <EXNotifications/EXNotificationCenterDelegate.h>
-
-#import <ExpoModulesCore/EXEventEmitterService.h>
-
-@interface EXNotificationsHandlerModule ()
-
-@property (nonatomic, weak) id<EXNotificationCenterDelegate> notificationCenterDelegate;
-
-@property (nonatomic, assign) BOOL isListening;
-@property (nonatomic, assign) BOOL isBeingObserved;
-
-@property (nonatomic, weak) id<EXEventEmitterService> eventEmitter;
-
-@property (nonatomic, strong) NSMutableDictionary<NSString *, EXSingleNotificationHandlerTask *> *tasksMap;
-
-@end
-
-@implementation EXNotificationsHandlerModule
-
-EX_EXPORT_MODULE(ExpoNotificationsHandlerModule);
-
-- (instancetype)init
-{
-  if (self = [super init]) {
-    _tasksMap = [NSMutableDictionary dictionary];
-  }
-  return self;
-}
-
-# pragma mark - Exported methods
-
-EX_EXPORT_METHOD_AS(handleNotificationAsync,
-                    handleNotificationAsync:(NSString *)identifier withBehavior:(NSDictionary *)behavior resolver:(EXPromiseResolveBlock)resolve rejecter:(EXPromiseRejectBlock)reject)
-{
-  EXSingleNotificationHandlerTask *task = _tasksMap[identifier];
-  if (!task) {
-    NSString *message = [NSString stringWithFormat:@"Failed to handle notification %@, it has already been handled.", identifier];
-    return reject(@"ERR_NOTIFICATION_HANDLED", message, nil);
-  }
-  NSError *error = [task handleResponse:behavior];
-  if (error) {
-    return reject(error.userInfo[@"code"], error.userInfo[@"message"], error);
-  } else {
-    resolve(nil);
-  }
-}
-
-# pragma mark - EXModuleRegistryConsumer
-
-- (void)setModuleRegistry:(EXModuleRegistry *)moduleRegistry
-{
-  _eventEmitter = [moduleRegistry getModuleImplementingProtocol:@protocol(EXEventEmitterService)];
-  _notificationCenterDelegate = [moduleRegistry getSingletonModuleForName:@"NotificationCenterDelegate"];
-}
-
-# pragma mark - EXEventEmitter
-
-- (NSArray<NSString *> *)supportedEvents
-{
-  return [EXSingleNotificationHandlerTask eventNames];
-}
-
-- (void)startObserving
-{
-  [self setIsBeingObserved:YES];
-}
-
-- (void)stopObserving
-{
-  [self setIsBeingObserved:NO];
-}
-
-- (void)setIsBeingObserved:(BOOL)isBeingObserved
-{
-  _isBeingObserved = isBeingObserved;
-  BOOL shouldListen = _isBeingObserved;
-  if (shouldListen && !_isListening) {
-    [_notificationCenterDelegate addDelegate:self];
-    _isListening = YES;
-  } else if (!shouldListen && _isListening) {
-    [_notificationCenterDelegate removeDelegate:self];
-    _isListening = NO;
-  }
-}
-
-# pragma mark - EXNotificationsDelegate
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler
-{
-  EXSingleNotificationHandlerTask *task = [[EXSingleNotificationHandlerTask alloc] initWithEventEmitter:_eventEmitter
-                                                                                           notification:notification
-                                                                                      completionHandler:completionHandler
-                                                                                               delegate:self];
-  [_tasksMap setObject:task forKey:task.identifier];
-  [task start];
-}
-
-# pragma mark - EXSingleNotificationHandlerTaskDelegate
-
-- (void)taskDidFinish:(EXSingleNotificationHandlerTask *)task
-{
-  [_tasksMap removeObjectForKey:task.identifier];
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXSingleNotificationHandlerTask.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXSingleNotificationHandlerTask.h
deleted file mode 100644
index b001ee6..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXSingleNotificationHandlerTask.h
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <Foundation/Foundation.h>
-#import <ExpoModulesCore/EXEventEmitterService.h>
-#import <UserNotifications/UserNotifications.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@class EXSingleNotificationHandlerTask;
-
-@protocol EXSingleNotificationHandlerTaskDelegate
-
-- (void)taskDidFinish:(EXSingleNotificationHandlerTask *)task;
-
-@end
-
-@interface EXSingleNotificationHandlerTask : NSObject
-
-+ (NSArray<NSString *> *)eventNames;
-
-- (instancetype)initWithEventEmitter:(id<EXEventEmitterService>)eventEmitter
-                        notification:(UNNotification *)notification
-                   completionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler
-                            delegate:(id<EXSingleNotificationHandlerTaskDelegate>)delegate;
-
-- (NSString *)identifier;
-
-- (void)start;
-- (nullable NSError *)handleResponse:(NSDictionary *)response;
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXSingleNotificationHandlerTask.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXSingleNotificationHandlerTask.m
deleted file mode 100644
index 25fcd67..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXSingleNotificationHandlerTask.m
+++ /dev/null
@@ -1,124 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXSingleNotificationHandlerTask.h>
-#import <EXNotifications/EXNotificationSerializer.h>
-
-static NSString * const onHandleNotification = @"onHandleNotification";
-static NSString * const onHandleNotificationTimeout = @"onHandleNotificationTimeout";
-
-static NSString * const shouldShowAlertKey = @"shouldShowAlert";
-static NSString * const shouldPlaySoundKey = @"shouldPlaySound";
-static NSString * const shouldSetBadgeKey = @"shouldSetBadge";
-
-static NSTimeInterval const secondsToTimeout = 3;
-
-static NSString * const EXNotificationHandlerErrorDomain = @"expo.notifications.handler";
-
-@interface EXSingleNotificationHandlerTask ()
-
-@property (nonatomic, weak) id<EXEventEmitterService> eventEmitter;
-@property (nonatomic, strong) UNNotification *notification;
-@property (nonatomic, copy) void (^completionHandler)(UNNotificationPresentationOptions);
-
-@property (nonatomic, weak) id<EXSingleNotificationHandlerTaskDelegate> delegate;
-
-@property (nonatomic, strong) NSTimer *timer;
-
-@end
-
-@implementation EXSingleNotificationHandlerTask
-
-+ (NSArray<NSString *> *)eventNames
-{
-  return @[onHandleNotification, onHandleNotificationTimeout];
-}
-
-- (instancetype)initWithEventEmitter:(id<EXEventEmitterService>)eventEmitter
-                        notification:(UNNotification *)notification
-                   completionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler
-                            delegate:(nonnull id<EXSingleNotificationHandlerTaskDelegate>)delegate
-{
-  if (self = [super init]) {
-    _eventEmitter = eventEmitter;
-    _notification = notification;
-    _completionHandler = completionHandler;
-    _delegate = delegate;
-  }
-  return self;
-}
-
-- (NSString *)identifier
-{
-  return _notification.request.identifier;
-}
-
-- (void)start
-{
-  [_eventEmitter sendEventWithName:onHandleNotification body:@{
-    @"id": _notification.request.identifier,
-    @"notification": [EXNotificationSerializer serializedNotification:_notification]
-  }];
-  _timer = [NSTimer scheduledTimerWithTimeInterval:secondsToTimeout target:self selector:@selector(handleTimeout) userInfo:nil repeats:NO];
-}
-
-- (nullable NSError *)handleResponse:(NSDictionary *)response
-{
-  @synchronized (self) {
-    NSError *maybeError = [self callCompletionHandlerWithOptions:[self presentationOptionsFromResponse:response]];
-    [self finish];
-    return maybeError;
-  }
-}
-
-- (void)handleTimeout
-{
-  @synchronized (self) {
-    [_eventEmitter sendEventWithName:onHandleNotificationTimeout body:@{
-      @"id": _notification.request.identifier,
-      @"notification": [EXNotificationSerializer serializedNotification:_notification]
-    }];
-    [self callCompletionHandlerWithOptions:UNNotificationPresentationOptionNone];
-    [self finish];
-  }
-}
-
-- (nullable NSError *)callCompletionHandlerWithOptions:(UNNotificationPresentationOptions)options
-{
-  if (_completionHandler) {
-    _completionHandler(options);
-    _completionHandler = nil;
-    return nil;
-  } else {
-    return [NSError errorWithDomain:EXNotificationHandlerErrorDomain code:-1 userInfo:@{
-      @"code": @"ERR_NOTIFICATION_RESPONSE_TIMEOUT",
-      @"message": @"Notification has already been handled. Most probably the request has timed out."
-    }];
-  }
-}
-
-- (void)finish
-{
-  [_timer invalidate];
-  _timer = nil;
-  [_delegate taskDidFinish:self];
-}
-
-- (UNNotificationPresentationOptions)presentationOptionsFromResponse:(NSDictionary *)response
-{
-  UNNotificationPresentationOptions options = UNNotificationPresentationOptionNone;
-
-  // TODO(iOS 14): use UNNotificationPresentationOptionList and UNNotificationPresentationOptionBanner
-  if ([response[shouldShowAlertKey] boolValue]) {
-    options |= UNNotificationPresentationOptionAlert;
-  }
-  if ([response[shouldPlaySoundKey] boolValue]) {
-    options |= UNNotificationPresentationOptionSound;
-  }
-  if ([response[shouldSetBadgeKey] boolValue]) {
-    options |= UNNotificationPresentationOptionBadge;
-  }
-
-  return options;
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/HandlerModule.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/HandlerModule.swift
new file mode 100644
index 0000000..5fc9e12
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/HandlerModule.swift
@@ -0,0 +1,69 @@
+//  Copyright © 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+let onHandleNotification = "onHandleNotification"
+let onHandleNotificationTimeout = "onHandleNotificationTimeout"
+
+public class HandlerModule: Module, NotificationDelegate, SingleNotificationHandlerTaskDelegate {
+  var tasksMap: [String: SingleNotificationHandlerTask] = [:]
+
+  public func definition() -> ModuleDefinition {
+    Name("ExpoNotificationsEmitter")
+
+    Events([onHandleNotification, onHandleNotificationTimeout])
+
+    OnStartObserving {
+      NotificationCenterManager.shared.addDelegate(self)
+    }
+
+    OnStopObserving {
+      NotificationCenterManager.shared.removeDelegate(self)
+    }
+
+    AsyncFunction("handleNotificationAsync") { (identifier: String, behavior: [String: Any], promise: Promise) in
+      guard let task = tasksMap[identifier] else {
+        promise.reject("ERR_NOTIFICATION_HANDLED", "Failed to handle notification \(identifier) because it has already been handled")
+        return
+      }
+      if task.handleResponse(behavior) {
+        promise.resolve(nil)
+      } else {
+        promise.reject("ERR_NOTIFICATION_RESPONSE_TIMEOUT", "Notification has already been handled. Most probably the request has timed out.")
+      }
+    }
+  }
+
+  // MARK: - NotificationDelegate
+
+  public func willPresent(_ notification: UNNotification, completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) -> Bool {
+    let task = SingleNotificationHandlerTask(notification: notification, completionHandler: completionHandler, delegate: self)
+    tasksMap[task.identifier] = task
+    task.start()
+    return true
+  }
+
+  // MARK: - SingleNotificationHandlerTaskDelegate
+
+  public func taskDidFinish(_ task: SingleNotificationHandlerTask) {
+    tasksMap[task.identifier] = nil
+  }
+
+  public func handleNotification(_ notification: UNNotification) {
+    sendEvent(onHandleNotification, [
+      "id": notification.request.identifier,
+      "notification": EXNotificationSerializer.serializedNotification(notification)
+    ])
+  }
+
+  public func handleNotificationTimeout(_ notification: UNNotification) {
+    sendEvent(onHandleNotificationTimeout, [
+      "id": notification.request.identifier,
+      "notification": EXNotificationSerializer.serializedNotification(notification)
+    ])
+  }
+
+
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/SingleNotificationHandlerTask.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/SingleNotificationHandlerTask.swift
new file mode 100644
index 0000000..b08bd44
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/SingleNotificationHandlerTask.swift
@@ -0,0 +1,86 @@
+//  Copyright © 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+
+let shouldShowAlertKey = "shouldShowAlert"
+let shouldPlaySoundKey = "shouldPlaySound"
+let shouldSetBadgeKey = "shouldSetBadge"
+
+public protocol SingleNotificationHandlerTaskDelegate {
+  func taskDidFinish(_ task: SingleNotificationHandlerTask)
+  func handleNotification(_ notification: UNNotification)
+  func handleNotificationTimeout(_ notification: UNNotification)
+}
+
+public class SingleNotificationHandlerTask {
+  public let identifier: String
+
+  private let notification: UNNotification
+  private var completionHandler: ((UNNotificationPresentationOptions) -> Void)?
+  private let delegate: SingleNotificationHandlerTaskDelegate
+
+  private var timer: Timer?
+
+  public init(
+    notification: UNNotification,
+    completionHandler: @escaping (UNNotificationPresentationOptions) -> Void,
+    delegate: SingleNotificationHandlerTaskDelegate
+  ) {
+    self.identifier = notification.request.identifier
+    self.delegate = delegate
+    self.notification = notification
+    self.completionHandler = completionHandler
+  }
+
+  public func start() {
+    delegate.handleNotification(notification)
+    timer = Timer.scheduledTimer(timeInterval: 3, target: self, selector: #selector(timeout), userInfo: nil, repeats: false)
+  }
+
+  @objc
+  public func timeout() {
+    delegate.handleNotificationTimeout(notification)
+    finish()
+  }
+
+  public func handleResponse(_ behavior: [String: Any]) -> Bool {
+    if let completionHandler = completionHandler {
+      completionHandler(presentationOptions(behavior))
+      finish()
+      return true
+    } else {
+      finish()
+      return false
+    }
+  }
+
+  public func finish() {
+    timer?.invalidate()
+    self.completionHandler = nil
+    delegate.taskDidFinish(self)
+  }
+
+
+  func presentationOptions(_ behavior: [String: Any]) -> UNNotificationPresentationOptions {
+    var options: UNNotificationPresentationOptions = []
+
+    /*
+    if let shouldShowAlert = behavior[shouldShowAlertKey] as? Bool, shouldShowAlert {
+      options.insert(.alert)
+    }
+     */
+
+    if let shouldPlaySound = behavior[shouldPlaySoundKey] as? Bool, shouldPlaySound {
+      options.insert(.sound)
+    }
+
+    if let shouldSetBadge = behavior[shouldSetBadgeKey] as? Bool, shouldSetBadge {
+      options.insert(.badge)
+    }
+
+    // TODO(iOS 14): use UNNotificationPresentationOptionList and UNNotificationPresentationOptionBanner
+
+    return options
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationCenterManager.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationCenterManager.swift
index e584c1e..83d4433 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationCenterManager.swift
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationCenterManager.swift
@@ -37,6 +37,7 @@ public class NotificationCenterManager: NSObject,
   @objc
   public static let shared = NotificationCenterManager()
 
+  var lastResponse: UNNotificationResponse?
   var delegates: [NotificationDelegate] = []
   var pendingResponses: [UNNotificationResponse] = []
   let userNotificationCenter: UNUserNotificationCenter = UNUserNotificationCenter.current()
