diff --git a/node_modules/expo-notifications/ios/EXNotifications.podspec b/node_modules/expo-notifications/ios/EXNotifications.podspec
index 2315d8c..f2d675b 100644
--- a/node_modules/expo-notifications/ios/EXNotifications.podspec
+++ b/node_modules/expo-notifications/ios/EXNotifications.podspec
@@ -16,12 +16,18 @@ Pod::Spec.new do |s|
 
   s.dependency 'ExpoModulesCore'
 
+  # Swift/Objective-C compatibility
+  s.pod_target_xcconfig = {
+    'DEFINES_MODULE' => 'YES',
+    'SWIFT_COMPILATION_MODE' => 'wholemodule'
+  }
+
   s.resource_bundles = {'ExpoNotifications_privacy' => ['PrivacyInfo.xcprivacy']}
 
   if !$ExpoUseSources&.include?(package['name']) && ENV['EXPO_USE_SOURCE'].to_i == 0 && File.exist?("#{s.name}.xcframework") && Gem::Version.new(Pod::VERSION) >= Gem::Version.new('1.10.0')
     s.source_files = "#{s.name}/**/*.h"
     s.vendored_frameworks = "#{s.name}.xcframework"
   else
-    s.source_files = "#{s.name}/**/*.{h,m}"
+    s.source_files = "#{s.name}/**/*.{h,m,swift}"
   end
 end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Badge/BadgeModule.swift b/node_modules/expo-notifications/ios/EXNotifications/Badge/BadgeModule.swift
new file mode 100644
index 0000000..f9a33d4
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Badge/BadgeModule.swift
@@ -0,0 +1,26 @@
+//  Copyright © 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+public class BadgeModule: Module {
+  public func definition() -> ModuleDefinition {
+    Name("ExpoBadgeModule")
+
+    AsyncFunction("getBadgeCountAsync") { () -> Int in
+      return EXSharedApplication().applicationIconBadgeNumber
+    }
+
+    AsyncFunction("setBadgeCountAsync") { (badgeCount: Int) -> Bool in
+      var result = false
+      UNUserNotificationCenter.current().getNotificationSettings { settings in
+        if settings.badgeSetting == .enabled {
+          EXSharedApplication().applicationIconBadgeNumber = badgeCount
+          result = true
+        }
+      }
+      return result
+    }
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/EXBadgeModule.h b/node_modules/expo-notifications/ios/EXNotifications/EXBadgeModule.h
deleted file mode 100644
index 76b2913..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/EXBadgeModule.h
+++ /dev/null
@@ -1,11 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@interface EXBadgeModule : EXExportedModule
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/EXBadgeModule.m b/node_modules/expo-notifications/ios/EXNotifications/EXBadgeModule.m
deleted file mode 100644
index 50b6784..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/EXBadgeModule.m
+++ /dev/null
@@ -1,36 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXBadgeModule.h>
-#import <ExpoModulesCore/EXUtilities.h>
-#import <UserNotifications/UserNotifications.h>
-
-@implementation EXBadgeModule
-
-EX_EXPORT_MODULE(ExpoBadgeModule)
-
-EX_EXPORT_METHOD_AS(getBadgeCountAsync,
-                    getBadgeCountAsync:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject)
-{
-  dispatch_async(dispatch_get_main_queue(), ^{
-    resolve(@([EXSharedApplication() applicationIconBadgeNumber]));
-  });
-}
-
-EX_EXPORT_METHOD_AS(setBadgeCountAsync,
-                    setBadgeCountAsync:(NSNumber *)badgeCount
-                    resolve:(EXPromiseResolveBlock)resolve
-                    reject:(EXPromiseRejectBlock)reject)
-{
-  [[UNUserNotificationCenter currentNotificationCenter] getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {
-    dispatch_async(dispatch_get_main_queue(), ^{
-      if (settings.badgeSetting == UNNotificationSettingEnabled) {
-        [EXSharedApplication() setApplicationIconBadgeNumber:badgeCount.integerValue];
-        resolve(@(YES));
-      } else {
-        resolve(@(NO));
-      }
-    });
-  }];
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/EXServerRegistrationModule.h b/node_modules/expo-notifications/ios/EXNotifications/EXServerRegistrationModule.h
deleted file mode 100644
index 22f2004..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/EXServerRegistrationModule.h
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@interface EXServerRegistrationModule : EXExportedModule
-
-- (NSString *)getInstallationId;
-
-- (void)getRegistrationInfoAsyncWithResolver:(EXPromiseResolveBlock)resolve
-                                    rejecter:(EXPromiseRejectBlock)reject;
-- (void)setRegistrationInfoAsync:(NSString *)registrationInfo
-                        resolver:(EXPromiseResolveBlock)resolve
-                        rejecter:(EXPromiseRejectBlock)reject;
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/EXServerRegistrationModule.m b/node_modules/expo-notifications/ios/EXNotifications/EXServerRegistrationModule.m
deleted file mode 100644
index 83e10fc..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/EXServerRegistrationModule.m
+++ /dev/null
@@ -1,195 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXServerRegistrationModule.h>
-
-// noop (used by code transform to ensure the versioning isn't applied)
-#define EX_UNVERSIONED(symbol) symbol
-
-static NSString * const kEXDeviceInstallationUUIDKey = EX_UNVERSIONED(@"EXDeviceInstallationUUIDKey");
-static NSString * const kEXDeviceInstallationUUIDLegacyKey = EX_UNVERSIONED(@"EXDeviceInstallUUIDKey");
-
-static NSString * const kEXRegistrationInfoKey = EX_UNVERSIONED(@"EXNotificationRegistrationInfoKey");
-
-@implementation EXServerRegistrationModule
-
-EX_EXPORT_MODULE(NotificationsServerRegistrationModule)
-
-EX_EXPORT_METHOD_AS(getInstallationIdAsync,
-                    getInstallationIdAsyncWithResolver:(EXPromiseResolveBlock)resolve
-                                              rejecter:(EXPromiseRejectBlock)reject)
-{
-  resolve([self getInstallationId]);
-}
-
-- (NSString *)getInstallationId
-{
-  NSString *installationId = [self fetchInstallationId];
-  if (installationId) {
-    return installationId;
-  }
-  
-  installationId = [[NSUUID UUID] UUIDString];
-  [self setInstallationId:installationId error:NULL];
-  return installationId;
-}
-
-- (nullable NSString *)fetchInstallationId
-{
-  NSString *installationId;
-  CFTypeRef keychainResult = NULL;
-  
-  if (SecItemCopyMatching((__bridge CFDictionaryRef)[self installationIdGetQuery], &keychainResult) == noErr) {
-    NSData *result = (__bridge_transfer NSData *)keychainResult;
-    NSString *value = [[NSString alloc] initWithData:result
-                                            encoding:NSUTF8StringEncoding];
-    // `initWithUUIDString` returns nil if string is not a valid UUID
-    if ([[NSUUID alloc] initWithUUIDString:value]) {
-      installationId = value;
-    }
-  }
-  
-  if (installationId) {
-    return installationId;
-  }
-  
-  // Uses required reason API based on the following reason: CA92.1
-  NSString *legacyUUID = [[NSUserDefaults standardUserDefaults] stringForKey:kEXDeviceInstallationUUIDLegacyKey];
-  if (legacyUUID) {
-    installationId = legacyUUID;
-
-    NSError *error = nil;
-    if ([self setInstallationId:installationId error:&error]) {
-      // We only remove the value from old storage once it's set and saved in the new storage.
-      [[NSUserDefaults standardUserDefaults] removeObjectForKey:kEXDeviceInstallationUUIDLegacyKey];
-    } else {
-      NSLog(@"Could not migrate device installation UUID from legacy storage: %@", error.description);
-    }
-  }
-  
-  return installationId;
-}
-
-- (BOOL)setInstallationId:(NSString *)installationId error:(NSError **)error
-{
-  // Delete existing UUID so we don't need to handle "duplicate item" error
-  SecItemDelete((__bridge CFDictionaryRef)[self installationIdSearchQuery]);
-  
-  OSStatus status = SecItemAdd((__bridge CFDictionaryRef)[self installationIdSetQuery:installationId], NULL);
-  if (status != errSecSuccess && error) {
-    *error = [NSError errorWithDomain:NSOSStatusErrorDomain code:status userInfo:nil];
-  }
-  return status == errSecSuccess;
-}
-
-# pragma mark - Keychain dictionaries
-
-- (NSDictionary *)keychainSearchQueryFor:(NSString *)key merging:(NSDictionary *)dictionaryToMerge
-{
-  NSData *encodedKey = [key dataUsingEncoding:NSUTF8StringEncoding];
-  NSMutableDictionary *query = [NSMutableDictionary dictionaryWithDictionary:@{
-    (__bridge id)kSecClass:(__bridge id)kSecClassGenericPassword,
-    (__bridge id)kSecAttrService:[NSBundle mainBundle].bundleIdentifier,
-    (__bridge id)kSecAttrGeneric:encodedKey,
-    (__bridge id)kSecAttrAccount:encodedKey
-  }];
-  [query addEntriesFromDictionary:dictionaryToMerge];
-  return query;
-}
-
-# pragma mark Installation ID
-
-- (NSDictionary *)installationIdSearchQueryMerging:(NSDictionary *)dictionaryToMerge
-{
-  return [self keychainSearchQueryFor:kEXDeviceInstallationUUIDKey merging:dictionaryToMerge];
-}
-
-- (NSDictionary *)installationIdSearchQuery
-{
-  return [self installationIdSearchQueryMerging:@{}];
-}
-
-- (NSDictionary *)installationIdGetQuery
-{
-  return [self installationIdSearchQueryMerging:@{
-    (__bridge id)kSecMatchLimit:(__bridge id)kSecMatchLimitOne,
-    (__bridge id)kSecReturnData:(__bridge id)kCFBooleanTrue
-  }];
-}
-
-- (NSDictionary *)installationIdSetQuery:(NSString *)deviceInstallationUUID
-{
-  return [self installationIdSearchQueryMerging:@{
-    (__bridge id)kSecValueData:[deviceInstallationUUID dataUsingEncoding:NSUTF8StringEncoding],
-    (__bridge id)kSecAttrAccessible:(__bridge id)kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly
-  }];
-}
-
-# pragma mark Registration information
-
-- (NSDictionary *)registrationSearchQueryMerging:(NSDictionary *)dictionaryToMerge
-{
-  return [self keychainSearchQueryFor:kEXRegistrationInfoKey merging:dictionaryToMerge];
-}
-
-- (NSDictionary *)registrationSearchQuery
-{
-  return [self registrationSearchQueryMerging:@{}];
-}
-
-- (NSDictionary *)registrationGetQuery
-{
-  return [self registrationSearchQueryMerging:@{
-    (__bridge id)kSecMatchLimit:(__bridge id)kSecMatchLimitOne,
-    (__bridge id)kSecReturnData:(__bridge id)kCFBooleanTrue
-  }];
-}
-
-- (NSDictionary *)registrationSetQuery:(NSString *)registration
-{
-  return [self registrationSearchQueryMerging:@{
-    (__bridge id)kSecValueData:[registration dataUsingEncoding:NSUTF8StringEncoding],
-    (__bridge id)kSecAttrAccessible:(__bridge id)kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly
-  }];
-}
-
-EX_EXPORT_METHOD_AS(getRegistrationInfoAsync,
-                    getRegistrationInfoAsyncWithResolver:(EXPromiseResolveBlock)resolve
-                                                rejecter:(EXPromiseRejectBlock)reject)
-{
-  CFTypeRef keychainResult = NULL;
-  OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)[self registrationGetQuery], &keychainResult);
-  if (status == noErr) {
-    NSData *result = (__bridge_transfer NSData *)keychainResult;
-    NSString *value = [[NSString alloc] initWithData:result
-                                            encoding:NSUTF8StringEncoding];
-    resolve(value);
-  } else if (status == errSecItemNotFound) {
-    resolve(nil);
-  } else {
-    NSError *error = [NSError errorWithDomain:NSOSStatusErrorDomain code:status userInfo:nil];
-    reject(@"ERR_NOTIFICATIONS_KEYCHAIN_ACCESS", @"Could not fetch registration information from keychain.", error);
-  }
-}
-
-EX_EXPORT_METHOD_AS(setRegistrationInfoAsync,
-                    setRegistrationInfoAsync:(NSString *)registrationInfo
-                                    resolver:(EXPromiseResolveBlock)resolve
-                                    rejecter:(EXPromiseRejectBlock)reject)
-{
-  // Delete existing registration so we don't need to handle "duplicate item" error
-  SecItemDelete((__bridge CFDictionaryRef)[self registrationSearchQuery]);
-  
-  if (registrationInfo) {
-    OSStatus status = SecItemAdd((__bridge CFDictionaryRef)[self registrationSetQuery:registrationInfo], NULL);
-    if (status == errSecSuccess) {
-      resolve(nil);
-    } else {
-      NSError *error = [NSError errorWithDomain:NSOSStatusErrorDomain code:status userInfo:nil];
-      reject(@"ERR_NOTIFICATIONS_KEYCHAIN_ACCESS", @"Could not save registration information into keychain.", error);
-    }
-  } else {
-    resolve(nil);
-  }
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/ServerRegistration/ServerRegistrationModule.swift b/node_modules/expo-notifications/ios/EXNotifications/ServerRegistration/ServerRegistrationModule.swift
new file mode 100644
index 0000000..0e5d51f
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/ServerRegistration/ServerRegistrationModule.swift
@@ -0,0 +1,166 @@
+//  Copyright © 2024 650 Industries. All rights reserved.
+
+// swiftlint:disable force_unwrapping
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+public class ServerRegistrationModule: Module {
+  public func definition() -> ModuleDefinition {
+    Name("NotificationsServerRegistrationModule")
+
+    AsyncFunction("getInstallationIdAsync") { () -> String in
+      return try getInstallationId()
+    }
+
+    AsyncFunction("getRegistrationInfoAsync") { () -> String? in
+      return try getRegistrationInfo()
+    }
+
+    AsyncFunction("setRegistrationInfoAsync") { (registrationInfo: String) in
+      try setRegistrationInfo(registrationInfo: registrationInfo)
+    }
+  }
+
+  // MARK: - Installation ID
+
+  private func getInstallationId() throws -> String {
+    // If item in keychain, return it
+    if let installationId = try getInstallationIdFromKeychain() {
+      return installationId
+    }
+
+    // Check UserDefaults for legacy ID
+    let legacyInstallationId = getLegacyInstallationIdFromUserDefaults()
+    if let legacyInstallationId = legacyInstallationId {
+      try setInstallationIdInKeychain(legacyInstallationId)
+      // If successfully saved in keychain, remove the value from UserDefaults,
+      // and return it
+      removeLegacyInstallationIdFromUserDefaults()
+      return legacyInstallationId
+    }
+
+    // Otherwise, create a new UUID and store it in keychain
+    let newInstallationId = UUID().uuidString
+    try setInstallationIdInKeychain(newInstallationId)
+    return newInstallationId
+  }
+
+  private func getInstallationIdFromKeychain() throws -> String? {
+    try fetchStringWithQuery(installationIdGetQuery())
+  }
+
+  private func setInstallationIdInKeychain(_ installationId: String) throws {
+    try storeStringWithQueries(search: installationIdSearchQuery(), set: installationIdSetQuery(installationId))
+  }
+
+  private func getLegacyInstallationIdFromUserDefaults() -> String? {
+    return UserDefaults.standard.string(forKey: kEXDeviceInstallationUUIDLegacyKey)
+  }
+
+  private func removeLegacyInstallationIdFromUserDefaults() {
+    UserDefaults.standard.removeObject(forKey: kEXDeviceInstallationUUIDLegacyKey)
+  }
+
+  private func installationIdSearchQueryMerging(_ dictionaryToMerge: [AnyHashable: Any]) -> CFDictionary {
+    return keychainSearchQueryFor(key: kEXDeviceInstallationUUIDKey, dictionaryToMerge: dictionaryToMerge)
+  }
+
+  private func installationIdSearchQuery() -> CFDictionary {
+    return installationIdSearchQueryMerging([:])
+  }
+
+  private func installationIdGetQuery() -> CFDictionary {
+    return installationIdSearchQueryMerging([
+      kSecMatchLimit: kSecMatchLimitOne,
+      kSecReturnData: kCFBooleanTrue!
+    ])
+  }
+
+  private func installationIdSetQuery(_ deviceInstallationUUID: String) -> CFDictionary {
+    return installationIdSearchQueryMerging([
+      kSecValueData: deviceInstallationUUID.data(using: .utf8)!,
+      kSecAttrAccessible: kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly
+    ])
+  }
+
+  // MARK: - Registration information
+
+  private func getRegistrationInfo() throws -> String? {
+    return try fetchStringWithQuery(registrationGetQuery())
+  }
+
+  private func setRegistrationInfo(registrationInfo: String) throws {
+    return try storeStringWithQueries(search: registrationSearchQuery(), set: registrationSetQuery(registrationInfo))
+  }
+
+  private func registrationSearchQueryMerging(_ dictionaryToMerge: [AnyHashable: Any]) -> CFDictionary {
+    return keychainSearchQueryFor(key: kEXRegistrationInfoKey, dictionaryToMerge: dictionaryToMerge)
+  }
+
+  private func registrationSearchQuery() -> CFDictionary {
+    return registrationSearchQueryMerging([:])
+  }
+
+  private func registrationGetQuery() -> CFDictionary {
+    return registrationSearchQueryMerging([
+      kSecMatchLimit: kSecMatchLimitOne,
+      kSecReturnData: kCFBooleanTrue!
+    ])
+  }
+
+  private func registrationSetQuery(_ registration: String) -> CFDictionary {
+    return registrationSearchQueryMerging([
+      kSecValueData: registration.data(using: .utf8)!,
+      kSecAttrAccessible: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
+    ])
+  }
+
+  // MARK: - Generic keychain methods
+
+  private func keychainSearchQueryFor(key: String, dictionaryToMerge: [AnyHashable: Any]) -> CFDictionary {
+    let encodedKey: Data = key.data(using: .utf8)!
+    let bundleIdentifier = Bundle.main.bundleIdentifier ?? ""
+    var query: [AnyHashable: Any] = [
+      kSecClass: kSecClassGenericPassword,
+      kSecAttrService: bundleIdentifier,
+      kSecAttrGeneric: encodedKey,
+      kSecAttrAccount: encodedKey
+    ]
+    dictionaryToMerge.forEach { (key: AnyHashable, value: Any) in
+      query[key] = value
+    }
+    return query as CFDictionary
+  }
+
+  private func fetchStringWithQuery(_ query: CFDictionary) throws -> String? {
+    var item: CFTypeRef?
+    let status = SecItemCopyMatching(query, &item)
+    if status == errSecSuccess {
+      guard let existingItem = item as? Data,
+        let installationId = String.init(data: existingItem, encoding: .utf8) else {
+        return nil
+      }
+      return installationId
+    }
+    if status == errSecItemNotFound {
+      return nil
+    }
+  throw Exception(name: "ERR_NOTIFICATIONS_KEYCHAIN_ACCESS", description: "Keychain access failed, status = \(status)", code: "\(status)")
+  }
+
+  private func storeStringWithQueries(search: CFDictionary, set: CFDictionary) throws {
+    SecItemDelete(search)
+    let status = SecItemAdd(set, nil)
+    if status != errSecSuccess {
+      throw Exception(name: "ERR_NOTIFICATIONS_KEYCHAIN_ACCESS", description: "Keychain access failed, status = \(status)", code: "\(status)")
+    }
+  }
+
+  private let kEXDeviceInstallationUUIDKey = "EXDeviceInstallationUUIDKey"
+  private let kEXDeviceInstallationUUIDLegacyKey = "EXDeviceInstallationUUIDKey"
+  private let kEXRegistrationInfoKey = "EXNotificationRegistrationInfoKey"
+}
+
+// swiftlint:enable force_unwrapping
