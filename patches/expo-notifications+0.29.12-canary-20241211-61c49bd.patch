diff --git a/node_modules/expo-notifications/expo-module.config.json b/node_modules/expo-notifications/expo-module.config.json
index de403d4..2a62ca6 100644
--- a/node_modules/expo-notifications/expo-module.config.json
+++ b/node_modules/expo-notifications/expo-module.config.json
@@ -2,7 +2,7 @@
   "name": "expo-notifications",
   "platforms": ["ios", "android"],
   "ios": {
-    "modules": ["BadgeModule", "ServerRegistrationModule", "PushTokenModule"],
+    "modules": ["BadgeModule", "CategoriesModule", "ServerRegistrationModule", "PushTokenModule", "SchedulerModule", "PresentationModule"],
     "appDelegateSubscribers": ["PushTokenAppDelegateSubscriber"]
   },
   "android": {
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Building/EXNotificationBuilder.h b/node_modules/expo-notifications/ios/EXNotifications/Building/EXNotificationBuilder.h
deleted file mode 100644
index 1089770..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Building/EXNotificationBuilder.h
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXInternalModule.h>
-
-#import <UserNotifications/UserNotifications.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@protocol EXNotificationBuilder
-
-- (UNMutableNotificationContent *)notificationContentFromRequest:(NSDictionary *)request;
-
-@end
-
-@interface EXNotificationBuilder : NSObject <EXInternalModule, EXNotificationBuilder>
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Building/EXNotificationBuilder.m b/node_modules/expo-notifications/ios/EXNotifications/Building/EXNotificationBuilder.m
deleted file mode 100644
index 53ec405..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Building/EXNotificationBuilder.m
+++ /dev/null
@@ -1,105 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXDefines.h>
-#import <EXNotifications/EXNotificationBuilder.h>
-#import <EXNotifications/NSDictionary+EXNotificationsVerifyingClass.h>
-
-@implementation EXNotificationBuilder
-
-EX_REGISTER_MODULE();
-
-+ (const NSArray<Protocol *> *)exportedInterfaces
-{
-  return @[@protocol(EXNotificationBuilder)];
-}
-
-- (UNMutableNotificationContent *)notificationContentFromRequest:(NSDictionary *)request
-{
-  UNMutableNotificationContent *content = [UNMutableNotificationContent new];
-  [content setTitle:[request objectForKey:@"title" verifyingClass:[NSString class]]];
-  [content setSubtitle:[request objectForKey:@"subtitle" verifyingClass:[NSString class]]];
-  [content setBody:[request objectForKey:@"body" verifyingClass:[NSString class]]];
-  [content setLaunchImageName:[request objectForKey:@"launchImageName" verifyingClass:[NSString class]]];
-  [content setBadge:[request objectForKey:@"badge" verifyingClass:[NSNumber class]]];
-  [content setUserInfo:[request objectForKey:@"data" verifyingClass:[NSDictionary class]]];
-  [content setCategoryIdentifier:[request objectForKey:@"categoryIdentifier" verifyingClass:[NSString class]]];
-  if ([request[@"sound"] isKindOfClass:[NSNumber class]]) {
-    [content setSound:[request[@"sound"] boolValue] ? [UNNotificationSound defaultSound] : nil];
-  } else if ([request[@"sound"] isKindOfClass:[NSString class]]) {
-    NSString *soundName = request[@"sound"];
-    if ([@"default" isEqualToString:soundName]) {
-      [content setSound:[UNNotificationSound defaultSound]];
-    } else if ([@"defaultCritical" isEqualToString:soundName]) {
-      [content setSound:[UNNotificationSound defaultCriticalSound]];
-    } else {
-      [content setSound:[UNNotificationSound soundNamed:soundName]];
-    }
-  }
-  NSMutableArray<UNNotificationAttachment *> *attachments = [NSMutableArray new];
-  [[request objectForKey:@"attachments" verifyingClass:[NSArray class]] enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
-    UNNotificationAttachment *attachment = [self attachmentFromRequest:obj];
-    if (attachment) {
-      [attachments addObject:attachment];
-    }
-  }];
-  [content setAttachments:attachments];
-  NSString *interruptionLevel = [request objectForKey:@"interruptionLevel" verifyingClass:[NSString class]];
-  if (interruptionLevel) {
-    content.interruptionLevel = [EXNotificationBuilder deserializeInterruptionLevel:interruptionLevel];
-  }
-  return content;
-}
-
-+ (UNNotificationInterruptionLevel)deserializeInterruptionLevel:(NSString *)interruptionLevel API_AVAILABLE(ios(15.0)) {
-  static NSDictionary *interruptionLevelMap;
-  if (!interruptionLevelMap) {
-    interruptionLevelMap = @{
-      @"passive": @(UNNotificationInterruptionLevelPassive),
-      @"active": @(UNNotificationInterruptionLevelActive),
-      @"timeSensitive": @(UNNotificationInterruptionLevelTimeSensitive),
-      @"critical": @(UNNotificationInterruptionLevelCritical)
-    };
-  }
-  
-  return [interruptionLevelMap[interruptionLevel] integerValue];
-}
-
-- (UNNotificationAttachment *)attachmentFromRequest:(NSDictionary *)request
-{
-  NSString *identifier = [request objectForKey:@"identifier" verifyingClass:[NSString class]] ?: @"";
-  NSURL *uri = [NSURL URLWithString:[request objectForKey:@"uri" verifyingClass:[NSString class]]];
-  NSError *error = nil;
-  UNNotificationAttachment *attachment = [UNNotificationAttachment attachmentWithIdentifier:identifier URL:uri options:[self attachmentOptionsFromRequest:request] error:&error];
-  if (error) {
-    EXLogWarn(@"[expo-notifications] Could not have created a notification attachment out of request: %@. Error: %@.", [request description], [error description]);
-    return nil;
-  }
-  return attachment;
-}
-
-- (NSDictionary *)attachmentOptionsFromRequest:(NSDictionary *)request
-{
-  NSMutableDictionary *options = [NSMutableDictionary new];
-  if ([request objectForKey:@"typeHint" verifyingClass:[NSString class]]) {
-    options[UNNotificationAttachmentOptionsTypeHintKey] = request[@"typeHint"];
-  }
-  if ([request objectForKey:@"hideThumbnail" verifyingClass:[NSNumber class]]) {
-    options[UNNotificationAttachmentOptionsThumbnailHiddenKey] = request[@"hideThumbnail"];
-  }
-  if ([request objectForKey:@"thumbnailClipArea" verifyingClass:[NSDictionary class]]) {
-    NSDictionary *area = request[@"thumbnailClipArea"];
-    NSNumber *x = [area objectForKey:@"x" verifyingClass:[NSNumber class]];
-    NSNumber *y = [area objectForKey:@"y" verifyingClass:[NSNumber class]];
-    NSNumber *width = [area objectForKey:@"width" verifyingClass:[NSNumber class]];
-    NSNumber *height = [area objectForKey:@"height" verifyingClass:[NSNumber class]];
-    CGRect areaRect = CGRectMake([x doubleValue], [y doubleValue], [width doubleValue], [height doubleValue]);
-    options[UNNotificationAttachmentOptionsThumbnailClippingRectKey] = (__bridge id _Nullable)(CGRectCreateDictionaryRepresentation(areaRect));
-  }
-  if ([request objectForKey:@"thumbnailTime" verifyingClass:[NSNumber class]]) {
-    options[UNNotificationAttachmentOptionsThumbnailTimeKey] = request[@"thumbnailTime"];
-  }
-  return options;
-}
-
-@end
-
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Building/NotificationBuilder.swift b/node_modules/expo-notifications/ios/EXNotifications/Building/NotificationBuilder.swift
new file mode 100644
index 0000000..6916264
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Building/NotificationBuilder.swift
@@ -0,0 +1,147 @@
+//  Copyright Â© 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+
+struct NotificationRequestRecord: Record {
+  @Field
+  var title: String?
+  @Field
+  var subtitle: String?
+  @Field
+  var body: String?
+  @Field
+  var launchImageName: String?
+  @Field
+  var badge: Int?
+  @Field
+  var userInfo: [String: Any]?
+  @Field
+  var categoryIdentifier: String?
+  @Field
+  var sound: Either<Bool, String>?
+  @Field
+  var attachments: [[String: Any]]?
+  @Field
+  var interruptionLevel: String?
+}
+
+public class NotificationBuilder: NSObject {
+  public class func content(_ request: [String: Any], appContext: AppContext) throws -> UNMutableNotificationContent {
+    let content = UNMutableNotificationContent()
+    let request = try NotificationRequestRecord(from: request, appContext: appContext)
+
+    if let title = request.title {
+      content.title = title
+    }
+
+    if let subtitle = request.subtitle {
+      content.subtitle = subtitle
+    }
+
+    if let body = request.body {
+      content.body = body
+    }
+
+    if let launchImageName = request.launchImageName {
+      content.launchImageName = launchImageName
+    }
+
+    if let badge = request.badge {
+      // swiftlint:disable:next legacy_objc_type
+      content.badge = NSNumber.init(value: badge)
+    }
+
+    if let userInfo = request.userInfo {
+      content.userInfo = userInfo
+    }
+
+    if let categoryIdentifier = request.categoryIdentifier {
+      content.categoryIdentifier = categoryIdentifier
+    }
+
+    if let sound = request.sound {
+      if let soundBool = try? sound.as(Bool.self) {
+        content.sound = soundBool ? .default : .none
+      } else if let soundName = try? sound.as(String.self) {
+        if soundName == "default" {
+          content.sound = UNNotificationSound.default
+        } else if soundName == "defaultCritical" {
+          content.sound = UNNotificationSound.defaultCritical
+        } else {
+          content.sound = UNNotificationSound(named: UNNotificationSoundName(rawValue: soundName))
+        }
+      }
+    }
+
+    var attachments: [UNNotificationAttachment] = []
+    if let attachmentsArray = request.attachments {
+      for attachmentObject in attachmentsArray {
+        if let attachment: UNNotificationAttachment = attachment(attachmentObject) {
+          attachments.append(attachment)
+        }
+      }
+    }
+    content.attachments = attachments
+    if let interruptionLevel = request.interruptionLevel {
+      content.interruptionLevel = deserializeInterruptionLevel(interruptionLevel)
+    }
+
+    return content
+  }
+
+  class func attachment(_ request: [String: Any]) -> UNNotificationAttachment? {
+    let identifier = request["identifier"] as? String ?? ""
+    let uri = request["uri"] as? String ?? ""
+    do {
+      if let url = URL(string: uri),
+        let attachment: UNNotificationAttachment =
+          try? UNNotificationAttachment(
+            identifier: identifier,
+            url: url,
+            options: attachmentOptions(request)
+          ) {
+        return attachment
+      }
+      return nil
+    }
+  }
+
+  class func attachmentOptions(_ request: [String: Any]) -> [String: Any] {
+    var options: [String: Any] = [:]
+    if let typeHint = request["typeHint"] as? String {
+      options[UNNotificationAttachmentOptionsTypeHintKey] = typeHint
+    }
+    if let hideThumbnail = request["hideThumbnail"] as? Bool {
+      options[UNNotificationAttachmentOptionsThumbnailHiddenKey] = hideThumbnail
+    }
+    if let thumbnailClipArea = request["thumbnailClipArea"] as? [String: Any] {
+      let x = thumbnailClipArea["x"] as? Double
+      let y = thumbnailClipArea["y"] as? Double
+      let width = thumbnailClipArea["width"] as? Double
+      let height = thumbnailClipArea["height"] as? Double
+      if let x, let y, let width, let height {
+        options[UNNotificationAttachmentOptionsThumbnailClippingRectKey] =
+          CGRect(
+            x: x,
+            y: y,
+            width: width,
+            height: height
+          )
+      }
+    }
+    if let thumbnailTime = request["thumbnailTime"] as? TimeInterval {
+      options[UNNotificationAttachmentOptionsThumbnailTimeKey] = thumbnailTime
+    }
+    return options
+  }
+
+  class func deserializeInterruptionLevel(_ interruptionLevel: String) -> UNNotificationInterruptionLevel {
+    switch interruptionLevel {
+    case "passive": return .passive
+    case "active": return .active
+    case "timeSensitive": return .timeSensitive
+    case "critical": return .critical
+    default: return .passive
+    }
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Categories/CategoriesModule.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Categories/CategoriesModule.swift
new file mode 100644
index 0000000..6d68423
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Categories/CategoriesModule.swift
@@ -0,0 +1,166 @@
+//  Copyright Â© 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+public class CategoriesModule: Module {
+  public func definition() -> ModuleDefinition {
+    Name("ExpoNotificationCategoriesModule")
+
+    AsyncFunction("getNotificationCategoriesAsync") { (promise: Promise) in
+      UNUserNotificationCenter.current().getNotificationCategories { categories in
+        var existingCategories: [[String: Any]] = []
+        categories.forEach { category in
+          existingCategories.append(self.serializeCategory(category))
+        }
+        promise.resolve(existingCategories)
+      }
+    }
+
+    AsyncFunction("setNotificationCategoryAsync") { (identifier: String, actions: [[String: Any]], options: [String: Any]?, promise: Promise) in
+      let newCategory = categoryFromParams(identifier, actions: actions, options: options)
+      UNUserNotificationCenter.current().getNotificationCategories { oldcategories in
+        var newCategories: Set<UNNotificationCategory> = Set<UNNotificationCategory>()
+        oldcategories.forEach { category in
+          if category.identifier != newCategory.identifier {
+            newCategories.insert(category)
+          }
+        }
+        newCategories.insert(newCategory)
+        UNUserNotificationCenter.current().setNotificationCategories(newCategories)
+        promise.resolve(self.serializeCategory(newCategory))
+      }
+    }
+
+    AsyncFunction("deleteNotificationCategoryAsync") { (identifier: String, promise: Promise) in
+      UNUserNotificationCenter.current().getNotificationCategories { oldcategories in
+        var newCategories: Set<UNNotificationCategory> = Set<UNNotificationCategory>()
+        var didDelete = false
+        oldcategories.forEach { category in
+          if category.identifier == identifier {
+            didDelete = true
+          } else {
+            newCategories.insert(category)
+          }
+        }
+        if didDelete {
+          UNUserNotificationCenter.current().setNotificationCategories(newCategories)
+        }
+        promise.resolve(didDelete)
+      }
+    }
+  }
+
+  func categoryFromParams(_ id: String, actions: [[String: Any]], options: [String: Any]?) -> UNNotificationCategory {
+    let intentIdentifiers: [String] = options?["intentIdentifiers"] as? [String] ?? []
+    let previewPlaceholder: String? = options?["previewPlaceholder"] as? String
+    let categorySummaryFormat: String? = options?["categorySummaryFormat"] as? String
+    var actionsArray: [UNNotificationAction] = []
+    actions.forEach { actionParams in
+      if let action = actionFromParams(actionParams) {
+        actionsArray.append(action)
+      }
+    }
+    let categoryOptions: UNNotificationCategoryOptions = categoryOptionsFromParams(options)
+    return UNNotificationCategory(
+      identifier: id,
+      actions: actionsArray,
+      intentIdentifiers: intentIdentifiers,
+      hiddenPreviewsBodyPlaceholder: previewPlaceholder,
+      categorySummaryFormat: categorySummaryFormat,
+      options: categoryOptions
+    )
+  }
+
+  func actionFromParams(_ params: [String: Any]) -> UNNotificationAction? {
+    guard let identifier = params["identifier"] as? String,
+      let buttonTitle = params["buttonTitle"] as? String else {
+      return nil
+    }
+    var options: UNNotificationActionOptions = []
+    if let optionsParams = params["options"] as? [String: Any] {
+      if optionsParams["opensAppToForeground"] as? Bool ?? false {
+        options.insert(.foreground)
+      }
+      if optionsParams["isDestructive"] as? Bool ?? false {
+        options.insert(.destructive)
+      }
+      if optionsParams["isAuthenticationRequired"] as? Bool ?? false {
+        options.insert(.authenticationRequired)
+      }
+    }
+    if let textInput = params["textInput"] as? [String: String] {
+      return UNTextInputNotificationAction(
+        identifier: identifier,
+        title: buttonTitle,
+        textInputButtonTitle: textInput["submitButtonTitle"] ?? "",
+        textInputPlaceholder: textInput["placeholder"] ?? ""
+      )
+    }
+    return UNTextInputNotificationAction(identifier: identifier, title: buttonTitle, options: options)
+  }
+
+  func categoryOptionsFromParams(_ params: [String: Any]?) -> UNNotificationCategoryOptions {
+    var options: UNNotificationCategoryOptions = []
+    if params?["customDismissAction"] as? Bool ?? false {
+      options.insert(.customDismissAction)
+    }
+    if params?["allowInCarPlay"] as? Bool ?? false {
+      options.insert(.allowInCarPlay)
+    }
+    if params?["showTitle"] as? Bool ?? false {
+      options.insert(.hiddenPreviewsShowTitle)
+    }
+    if params?["showSubtitle"] as? Bool ?? false {
+      options.insert(.hiddenPreviewsShowSubtitle)
+    }
+    return options
+  }
+
+  func serializeCategory(_ category: UNNotificationCategory) -> [String: Any] {
+    return [
+      "identifier": category.identifier,
+      "actions": serializeActions(category.actions),
+      "options": serializeCategoryOptions(category)
+    ]
+  }
+
+  func serializeActions(_ actions: [UNNotificationAction]) -> [[String: Any]] {
+    return actions.map { action in
+      var serializedAction: [String: Any] = [
+        "identifier": action.identifier,
+        "title": action.title,
+        "options": serializeActionOptions(action.options)
+      ]
+      if let textInputAction = action as? UNTextInputNotificationAction {
+        serializedAction["textInput"] = [
+          "placeholder": textInputAction.textInputPlaceholder,
+          "submitButtonTitle": textInputAction.textInputButtonTitle
+        ]
+      }
+      return serializedAction
+    }
+  }
+
+  func serializeCategoryOptions(_ category: UNNotificationCategory) -> [String: Any] {
+    return [
+      "allowAnnouncement": category.options.contains(.allowAnnouncement),
+      "allowInCarPlay": category.options.contains(.allowInCarPlay),
+      "categorySummaryFormat": category.categorySummaryFormat,
+      "customDismissAction": category.options.contains(.customDismissAction),
+      "intentIdentifiers": category.intentIdentifiers,
+      "previewPlaceholder": category.hiddenPreviewsBodyPlaceholder,
+      "showTitle": category.options.contains(.hiddenPreviewsShowTitle),
+      "showSubtitle": category.options.contains(.hiddenPreviewsShowSubtitle)
+    ]
+  }
+
+  func serializeActionOptions(_ options: UNNotificationActionOptions) -> [String: Any] {
+    return [
+      "destructive": options.contains(.destructive),
+      "authenticationRequired": options.contains(.authenticationRequired),
+      "foreground": options.contains(.foreground)
+    ]
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Categories/EXNotificationCategoriesModule.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Categories/EXNotificationCategoriesModule.h
deleted file mode 100644
index 85806cf..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Categories/EXNotificationCategoriesModule.h
+++ /dev/null
@@ -1,25 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-#import <EXNotifications/EXNotificationsDelegate.h>
-
-@interface EXNotificationCategoriesModule : EXExportedModule <EXNotificationsDelegate>
-
-- (void)getNotificationCategoriesAsyncWithResolver:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject;
-- (void)setNotificationCategoryWithCategoryId:(NSString *)categoryId
-                                      actions:(NSArray *)actions
-                                      options:(NSDictionary *)options
-                                      resolve:(EXPromiseResolveBlock)resolve 
-                                       reject:(EXPromiseRejectBlock)reject;
-- (void)deleteNotificationCategoryWithCategoryId:(NSString *)categoryId
-                                         resolve:(EXPromiseResolveBlock)resolve 
-                                          reject:(EXPromiseRejectBlock)reject;
-- (NSMutableDictionary *)serializeCategory:(UNNotificationCategory *)category;
-- (UNNotificationCategory *)createCategoryWithId:(NSString*)categoryId
-                                         actions:(NSArray *)actions
-                                         options:(NSDictionary *)options;
-- (NSMutableDictionary *)serializeCategoryOptions:(UNNotificationCategory *)category;
-- (NSMutableArray *)serializeActions:(NSArray<UNNotificationAction *>*)actions;
-- (NSMutableDictionary *)serializeActionOptions:(NSUInteger)options;
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Categories/EXNotificationCategoriesModule.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Categories/EXNotificationCategoriesModule.m
deleted file mode 100644
index 4a87f5d..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Categories/EXNotificationCategoriesModule.m
+++ /dev/null
@@ -1,189 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXNotificationCategoriesModule.h>
-#import <EXNotifications/EXNotificationCenterDelegate.h>
-
-@implementation EXNotificationCategoriesModule
-
-EX_EXPORT_MODULE(ExpoNotificationCategoriesModule);
-
-# pragma mark - Exported methods
-
-EX_EXPORT_METHOD_AS(getNotificationCategoriesAsync,
-                 getNotificationCategoriesAsyncWithResolver:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject)
-{
-  [[UNUserNotificationCenter currentNotificationCenter] getNotificationCategoriesWithCompletionHandler:^(NSSet<UNNotificationCategory *> *categories) {
-    NSMutableArray* existingCategories = [NSMutableArray new];
-    for (UNNotificationCategory *category in categories) {
-      [existingCategories addObject:[self serializeCategory:category]];
-    }
-    resolve(existingCategories);
-  }];
-}
-
-EX_EXPORT_METHOD_AS(setNotificationCategoryAsync,
-                 setNotificationCategoryWithCategoryId:(NSString *)categoryId
-                 actions:(NSArray *)actions
-                 options:(NSDictionary *)options
-                 resolve:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject)
-{
-  UNNotificationCategory *newCategory = [EXNotificationCategoriesModule createCategoryWithId:categoryId
-                                                                                     actions:actions
-                                                                                     options:options];
-  
-  [[UNUserNotificationCenter currentNotificationCenter] getNotificationCategoriesWithCompletionHandler:^(NSSet<UNNotificationCategory *> *categories) {
-    NSMutableSet<UNNotificationCategory *> *newCategories = [categories mutableCopy] ?: [[NSMutableSet alloc] init];
-    for (UNNotificationCategory *category in newCategories) {
-      if ([category.identifier isEqualToString:newCategory.identifier]) {
-        [newCategories removeObject:category];
-        break;
-      }
-    }
-    [newCategories addObject:newCategory];
-    [[UNUserNotificationCenter currentNotificationCenter] setNotificationCategories:newCategories];
-    resolve([self serializeCategory:newCategory]);
-  }];
-}
-
-EX_EXPORT_METHOD_AS(deleteNotificationCategoryAsync,
-                 deleteNotificationCategoryWithCategoryId:(NSString *)categoryId
-                 resolve:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject)
-{
-  [[UNUserNotificationCenter currentNotificationCenter] getNotificationCategoriesWithCompletionHandler:^(NSSet<UNNotificationCategory *> *categories) {
-    BOOL didDelete = NO;
-    NSMutableSet<UNNotificationCategory *> *newCategories = [categories mutableCopy];
-    for (UNNotificationCategory *category in newCategories) {
-      if ([category.identifier isEqualToString:categoryId]) {
-        [newCategories removeObject:category];
-        didDelete = YES;
-        break;
-      }
-    }
-    [[UNUserNotificationCenter currentNotificationCenter] setNotificationCategories:newCategories];
-    resolve(@(didDelete));
-  }];
-}
-
-# pragma mark- Internal
-
-+ (UNNotificationCategory *)createCategoryWithId:(NSString*)categoryId
-                                         actions:(NSArray *)actions
-                                         options:(NSDictionary *)options
-{
-  NSArray<NSString *> *intentIdentifiers = options[@"intentIdentifiers"];
-  NSString *previewPlaceholder = options[@"previewPlaceholder"];
-  NSString *categorySummaryFormat = options[@"categorySummaryFormat"];
-
-  NSMutableArray<UNNotificationAction *> *actionsArray = [[NSMutableArray alloc] init];
-  for (NSDictionary<NSString *, id> *actionParams in actions) {
-    [actionsArray addObject:[self parseNotificationActionFromParams:actionParams]];
-  }
-  UNNotificationCategoryOptions categoryOptions = [self parseNotificationCategoryOptionsFromParams: options];
-  return [UNNotificationCategory categoryWithIdentifier:categoryId
-                                                actions:actionsArray
-                                      intentIdentifiers:intentIdentifiers
-                          hiddenPreviewsBodyPlaceholder:previewPlaceholder
-                                  categorySummaryFormat:categorySummaryFormat
-                                                options:categoryOptions];
-}
-
-+ (UNNotificationAction *)parseNotificationActionFromParams:(NSDictionary *)params
-{
-  NSString *identifier = params[@"identifier"];
-  NSString *buttonTitle = params[@"buttonTitle"];
-  UNNotificationActionOptions options = UNNotificationActionOptionNone;
-
-  if (params[@"options"][@"opensAppToForeground"] == nil || [params[@"options"][@"opensAppToForeground"] boolValue]) {
-    options += UNNotificationActionOptionForeground;
-  }
-  if ([params[@"options"][@"isDestructive"] boolValue]) {
-    options += UNNotificationActionOptionDestructive;
-  }
-  if ([params[@"options"][@"isAuthenticationRequired"] boolValue]) {
-    options += UNNotificationActionOptionAuthenticationRequired;
-  }
-
-  if ([params[@"textInput"] isKindOfClass:[NSDictionary class]]) {
-    return [UNTextInputNotificationAction actionWithIdentifier:identifier
-                                                         title:buttonTitle
-                                                       options:options
-                                          textInputButtonTitle:params[@"textInput"][@"submitButtonTitle"]
-                                          textInputPlaceholder:params[@"textInput"][@"placeholder"]];
-  }
-
-  return [UNNotificationAction actionWithIdentifier:identifier title:buttonTitle options:options];
-}
-
-+ (UNNotificationCategoryOptions )parseNotificationCategoryOptionsFromParams:(NSDictionary *)params
-{
-  UNNotificationCategoryOptions options = UNNotificationCategoryOptionNone;
-  if ([params[@"customDismissAction"] boolValue]) {
-    options += UNNotificationCategoryOptionCustomDismissAction;
-  }
-  if ([params[@"allowInCarPlay"] boolValue]) {
-    options += UNNotificationCategoryOptionAllowInCarPlay;
-  }
-  if ([params[@"showTitle"] boolValue]) {
-    options += UNNotificationCategoryOptionHiddenPreviewsShowTitle;
-  }
-  if ([params[@"showSubtitle"] boolValue]) {
-    options += UNNotificationCategoryOptionHiddenPreviewsShowSubtitle;
-  }
-
-  return options;
-}
-
-- (NSMutableDictionary *)serializeCategory:(UNNotificationCategory *)category
-{
-  NSMutableDictionary* serializedCategory = [NSMutableDictionary dictionary];
-  serializedCategory[@"identifier"] = category.identifier;
-  serializedCategory[@"actions"] = [self serializeActions: category.actions];
-  serializedCategory[@"options"] = [self serializeCategoryOptions: category];
-  return serializedCategory;
-}
-
-- (NSMutableDictionary *)serializeCategoryOptions:(UNNotificationCategory *)category
-{
-  NSMutableDictionary* serializedOptions = [NSMutableDictionary dictionary];
-  serializedOptions[@"intentIdentifiers"] = category.intentIdentifiers;
-  serializedOptions[@"customDismissAction"] =  [NSNumber numberWithBool:((category.options & UNNotificationCategoryOptionCustomDismissAction) != 0)];
-  serializedOptions[@"allowInCarPlay"] = [NSNumber numberWithBool:((category.options & UNNotificationCategoryOptionAllowInCarPlay) != 0)];
-  serializedOptions[@"previewPlaceholder"] = category.hiddenPreviewsBodyPlaceholder;
-  serializedOptions[@"showTitle"] =  [NSNumber numberWithBool:((category.options & UNNotificationCategoryOptionHiddenPreviewsShowTitle) != 0)];
-  serializedOptions[@"showSubtitle"] = [NSNumber numberWithBool:((category.options & UNNotificationCategoryOptionHiddenPreviewsShowSubtitle) != 0)];
-  serializedOptions[@"categorySummaryFormat"] = category.categorySummaryFormat;
-  serializedOptions[@"allowAnnouncement"] = [NSNumber numberWithBool:((category.options & UNNotificationActionOptionAuthenticationRequired) != 0)];
-  return serializedOptions;
-}
-
-- (NSMutableArray *)serializeActions:(NSArray<UNNotificationAction *>*)actions
-{
-  NSMutableArray* serializedActions = [NSMutableArray new];
-  for (NSUInteger i = 0; i < [actions count]; i++)
-  {
-    NSMutableDictionary *actionDictionary = [NSMutableDictionary dictionary];
-    actionDictionary[@"buttonTitle"] = actions[i].title;
-    actionDictionary[@"identifier"] = actions[i].identifier;
-    actionDictionary[@"options"] = [self serializeActionOptions:actions[i].options];
-    if ([actions[i] isKindOfClass:[UNTextInputNotificationAction class]]) {
-      UNTextInputNotificationAction *textInputAction = (UNTextInputNotificationAction *)actions[i];
-      NSMutableDictionary *textInputOptions = [NSMutableDictionary dictionary];
-      textInputOptions[@"placeholder"] = textInputAction.textInputPlaceholder;
-      textInputOptions[@"submitButtonTitle"] = textInputAction.textInputButtonTitle;
-      actionDictionary[@"textInput"] = textInputOptions;
-    }
-    [serializedActions addObject:actionDictionary];
-  }
-  return serializedActions;
-}
-
-- (NSMutableDictionary *)serializeActionOptions:(NSUInteger)options
-{
-  NSMutableDictionary* serializedOptions = [NSMutableDictionary dictionary];
-  serializedOptions[@"opensAppToForeground"] =  [NSNumber numberWithBool:((options & UNNotificationActionOptionForeground) != 0)];
-  serializedOptions[@"isDestructive"] = [NSNumber numberWithBool:((options & UNNotificationActionOptionDestructive) != 0)];
-  serializedOptions[@"isAuthenticationRequired"] = [NSNumber numberWithBool:((options & UNNotificationActionOptionAuthenticationRequired) != 0)];
-  return serializedOptions;
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.h
index 91436d8..d3423bf 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.h
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.h
@@ -22,10 +22,11 @@ NS_ASSUME_NONNULL_BEGIN
 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary<UIApplicationLaunchOptionsKey,id> *)launchOptions;
 - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler;
 
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler;
 - (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler;
+/*
+- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler;
 - (void)userNotificationCenter:(UNUserNotificationCenter *)center openSettingsForNotification:(nullable UNNotification *)notification;
-
+ */
 @property (nonatomic, strong, nullable) UNNotificationResponse *lastNotificationResponse;
 
 @end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.m
index 934470e..240b229 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.m
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.m
@@ -4,10 +4,17 @@
 #import <ExpoModulesCore/EXDefines.h>
 #import <EXNotifications/EXNotificationsDelegate.h>
 
+#if __has_include(<ExpoModulesCore/ExpoModulesCore-Swift.h>)
+#import <EXNotifications/EXNotifications-Swift.h>
+#else
+#import "EXNotifications-Swift.h"
+#endif
+
 @interface EXNotificationCenterDelegate ()
 
 @property (nonatomic, strong) NSPointerArray *delegates;
 @property (nonatomic, strong) NSMutableArray<UNNotificationResponse *> *pendingNotificationResponses;
+@property (nonatomic, weak) EXNotificationCenterManager *notificationCenterManager;
 
 @end
 
@@ -20,6 +27,7 @@ EX_REGISTER_SINGLETON_MODULE(NotificationCenterDelegate);
   if (self = [super init]) {
     _delegates = [NSPointerArray weakObjectsPointerArray];
     _pendingNotificationResponses = [NSMutableArray array];
+    _notificationCenterManager = [EXNotificationCenterManager shared];
   }
   return self;
 }
@@ -90,35 +98,8 @@ EX_REGISTER_SINGLETON_MODULE(NotificationCenterDelegate);
 
 - (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler
 {
-  __block int delegatesCalled = 0;
-  __block int delegatesCompleted = 0;
-  __block BOOL delegatingCompleted = NO;
-  __block UNNotificationPresentationOptions optionsSum = UNNotificationPresentationOptionNone;
-  __block void (^completionHandlerCaller)(void) = ^{
-    if (delegatingCompleted && delegatesCompleted == delegatesCalled) {
-      completionHandler(optionsSum);
-    }
-  };
-
-  for (int i = 0; i < _delegates.count; i++) {
-    id pointer = [_delegates pointerAtIndex:i];
-    if ([pointer respondsToSelector:@selector(userNotificationCenter:willPresentNotification:withCompletionHandler:)]) {
-      [pointer userNotificationCenter:center willPresentNotification:notification withCompletionHandler:^(UNNotificationPresentationOptions options) {
-        @synchronized (self) {
-          delegatesCompleted += 1;
-          optionsSum = optionsSum | options;
-          completionHandlerCaller();
-        }
-      }];
-      @synchronized (self) {
-        delegatesCalled += 1;
-      }
-    }
-  }
-  @synchronized (self) {
-    delegatingCompleted = YES;
-    completionHandlerCaller();
-  }
+  // Delegate to the new Swift code
+  [_notificationCenterManager userNotificationCenter:center willPresentNotification:notification withCompletionHandler:completionHandler];
 }
 
 - (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler
@@ -169,12 +150,8 @@ EX_REGISTER_SINGLETON_MODULE(NotificationCenterDelegate);
 
 - (void)userNotificationCenter:(UNUserNotificationCenter *)center openSettingsForNotification:(UNNotification *)notification
 {
-  for (int i = 0; i < _delegates.count; i++) {
-    id pointer = [_delegates pointerAtIndex:i];
-    if ([pointer respondsToSelector:@selector(userNotificationCenter:openSettingsForNotification:)]) {
-      [pointer userNotificationCenter:center openSettingsForNotification:notification];
-    }
-  }
+  // Delegate to the new Swift manager
+  [_notificationCenterManager userNotificationCenter:center openSettingsForNotification:notification];
 }
 
 # pragma mark - EXNotificationCenterDelegate
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/NSDictionary+EXNotificationsVerifyingClass.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/NSDictionary+EXNotificationsVerifyingClass.h
deleted file mode 100644
index 802a40e..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/NSDictionary+EXNotificationsVerifyingClass.h
+++ /dev/null
@@ -1,7 +0,0 @@
-#import <Foundation/Foundation.h>
-
-@interface NSDictionary (EXNotificationsVerifyingClass)
-
-- (id)objectForKey:(id)aKey verifyingClass:(__unsafe_unretained Class)klass;
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/NSDictionary+EXNotificationsVerifyingClass.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/NSDictionary+EXNotificationsVerifyingClass.m
deleted file mode 100644
index 8671d67..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/NSDictionary+EXNotificationsVerifyingClass.m
+++ /dev/null
@@ -1,19 +0,0 @@
-#import <EXNotifications/NSDictionary+EXNotificationsVerifyingClass.h>
-
-static NSString * const invalidValueExceptionName = @"Value of invalid class encountered";
-static NSString * const invalidValueClassReasonFormat = @"Value under key `%@` is of class %@, while %@ was expected.";
-
-@implementation NSDictionary (EXNotificationsVerifyingClass)
-
-- (id)objectForKey:(id)aKey verifyingClass:(__unsafe_unretained Class)klass
-{
-  id obj = [self objectForKey:aKey];
-  if (!obj || [obj isKindOfClass:klass]) {
-    return obj;
-  }
-
-  NSString *reason = [NSString stringWithFormat:invalidValueClassReasonFormat, aKey, NSStringFromClass([obj class]), NSStringFromClass(klass)];
-  @throw [NSException exceptionWithName:invalidValueExceptionName reason:reason userInfo:nil];
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationCenterManager.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationCenterManager.swift
new file mode 100644
index 0000000..ce499b0
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationCenterManager.swift
@@ -0,0 +1,134 @@
+import ExpoModulesCore
+import Foundation
+
+/**
+ Protocol that NotificationCenterManager delegates may implement
+ */
+public protocol NotificationDelegate: AnyObject {
+  func willPresent(_ notification: UNNotification, completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) -> Bool
+  func didReceive(_ response: UNNotificationResponse, completionHandler: @escaping () -> Void) -> Bool
+  func openSettings(_ notification: UNNotification?)
+  func didRegister(_ deviceToken: String)
+  func didFailRegistration(_ error: Error)
+}
+
+public extension NotificationDelegate {
+  func willPresent(_ notification: UNNotification, completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) -> Bool {
+    return false
+  }
+  func didReceive(_ response: UNNotificationResponse, completionHandler: @escaping () -> Void) -> Bool {
+    return false
+  }
+  func openSettings(_ notification: UNNotification?) {}
+  func didRegister(_ deviceToken: String) {}
+  func didFailRegistration(_ error: Error) {}
+}
+
+/**
+ Singleton that sets itself as the UserNotificationCenter delegate,
+ and calls its own delegates in response to notification center calls.
+ */
+@objc(EXNotificationCenterManager)
+public class NotificationCenterManager: NSObject,
+  UNUserNotificationCenterDelegate,
+  NotificationDelegate {
+  @objc
+  public static let shared = NotificationCenterManager()
+
+  var delegates: [NotificationDelegate] = []
+  var pendingResponses: [UNNotificationResponse] = []
+  let userNotificationCenter: UNUserNotificationCenter = UNUserNotificationCenter.current()
+
+  // TODO: Once Swift conversion is complete, the old EXNotificationDelegate class will be removed, and
+  // we will need to add the initialization code below.
+  // For now, we allow EXNotificationDelegate to add itself as the user notification delegate, and call the
+  // shared instance of this class.
+  //
+  /*
+  private override init() {
+    super.init()
+    if UNUserNotificationCenter.current().delegate != nil {
+      NSLog(
+        "[expo-notifications] EXNotificationCenterDelegate encountered already present delegate of " +
+        "UNUserNotificationCenter. EXNotificationCenterDelegate will not overwrite the value not to break other " +
+        "features of your app.  In return, expo-notifications may not work properly.  To fix this problem either " +
+        "remove setting of the second delegate, or set the delegate to an instance of EXNotificationCenterDelegate " +
+        "manually afterwards."
+      )
+      return
+    }
+    UNUserNotificationCenter.current().delegate = self
+  }
+   */
+
+  public func addDelegate(_ delegate: NotificationDelegate) {
+    delegates.append(delegate)
+    var handled = false
+    for pendingResponse in pendingResponses {
+      handled = delegate.didReceive(pendingResponse, completionHandler: {})
+    }
+    if handled {
+      pendingResponses.removeAll()
+    }
+  }
+
+  public func removeDelegate(_ delegate: AnyObject) {
+    if let index = delegates.firstIndex(where: { $0 === delegate }) {
+      delegates.remove(at: index)
+    }
+  }
+
+  // MARK: - Called by PushTokenAppDelegateSubscriber
+
+  public func didFailRegistration(_ error: any Error) {
+    for delegate in delegates {
+      delegate.didFailRegistration(error)
+    }
+  }
+
+  public func didRegister(_ deviceToken: String) {
+    for delegate in delegates {
+      delegate.didRegister(deviceToken)
+    }
+  }
+
+  // MARK: - UNUserNotificationCenterDelegate
+
+  public func userNotificationCenter(
+    _ center: UNUserNotificationCenter,
+    willPresent notification: UNNotification,
+    withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void
+  ) {
+    var handled = false
+    for delegate in delegates {
+      handled = handled || delegate.willPresent(notification, completionHandler: completionHandler)
+    }
+    if !handled {
+      // TODO: For now, until all code is converted to Swift,
+      // ensure notification is presented even if handlers are not registered
+      // Later revisit this
+      completionHandler([.badge, .banner, .sound])
+    }
+  }
+
+  public func userNotificationCenter(
+    _ center: UNUserNotificationCenter,
+    didReceive response: UNNotificationResponse,
+    withCompletionHandler completionHandler: @escaping () -> Void
+  ) {
+    var handled = false
+    for delegate in delegates {
+      handled = handled || delegate.didReceive(response, completionHandler: completionHandler)
+    }
+    if !handled {
+      pendingResponses.append(response)
+    }
+    completionHandler()
+  }
+
+  public func userNotificationCenter(_ center: UNUserNotificationCenter, openSettingsFor notification: UNNotification?) {
+    for delegate in delegates {
+      delegate.openSettings(notification)
+    }
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/EXNotificationPresentationModule.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/EXNotificationPresentationModule.h
deleted file mode 100644
index f0f3dbd..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/EXNotificationPresentationModule.h
+++ /dev/null
@@ -1,13 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-#import <ExpoModulesCore/EXModuleRegistryConsumer.h>
-#import <EXNotifications/EXNotificationsDelegate.h>
-
-@interface EXNotificationPresentationModule : EXExportedModule <EXModuleRegistryConsumer, EXNotificationsDelegate>
-
-- (NSArray * _Nonnull)serializeNotifications:(NSArray<UNNotification *> * _Nonnull)notifications;
-
-- (void)dismissNotificationWithIdentifier:(NSString *)identifier resolve:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject;
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/EXNotificationPresentationModule.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/EXNotificationPresentationModule.m
deleted file mode 100644
index 8410fa4..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/EXNotificationPresentationModule.m
+++ /dev/null
@@ -1,124 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXNotificationPresentationModule.h>
-
-#import <EXNotifications/EXNotificationBuilder.h>
-#import <EXNotifications/EXNotificationSerializer.h>
-#import <EXNotifications/EXNotificationCenterDelegate.h>
-
-@interface EXNotificationPresentationModule ()
-
-@property (nonatomic, weak) id<EXNotificationBuilder> notificationBuilder;
-
-// Remove once presentNotificationAsync is removed
-@property (nonatomic, strong) NSCountedSet<NSString *> *presentedNotifications;
-@property (nonatomic, weak) id<EXNotificationCenterDelegate> notificationCenterDelegate;
-
-@end
-
-@implementation EXNotificationPresentationModule
-
-EX_EXPORT_MODULE(ExpoNotificationPresenter);
-
-// Remove once presentNotificationAsync is removed
-- (instancetype)init
-{
-  if (self = [super init]) {
-    _presentedNotifications = [NSCountedSet set];
-  }
-  return self;
-}
-
-# pragma mark - Exported methods
-
-// Remove once presentNotificationAsync is removed
-EX_EXPORT_METHOD_AS(presentNotificationAsync,
-                    presentNotificationWithIdentifier:(NSString *)identifier
-                    notification:(NSDictionary *)notificationSpec
-                    resolve:(EXPromiseResolveBlock)resolve
-                    reject:(EXPromiseRejectBlock)reject)
-{
-  UNNotificationContent *content = [_notificationBuilder notificationContentFromRequest:notificationSpec];
-  UNNotificationTrigger *trigger = nil;
-  UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:identifier content:content trigger:trigger];
-  [_presentedNotifications addObject:identifier];
-  __weak EXNotificationPresentationModule *weakSelf = self;
-  [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {
-    if (error) {
-      // If there was no error, willPresentNotification: callback will remove the identifier from the set
-      [weakSelf.presentedNotifications removeObject:identifier];
-      NSString *message = [NSString stringWithFormat:@"Notification could not have been presented: %@", error.description];
-      reject(@"ERR_NOTIF_PRESENT", message, error);
-    } else {
-      resolve(identifier);
-    }
-  }];
-}
-
-EX_EXPORT_METHOD_AS(getPresentedNotificationsAsync,
-                    getPresentedNotificationsAsyncWithResolve:(EXPromiseResolveBlock)resolve
-                    reject:(EXPromiseRejectBlock)reject)
-{
-  [[UNUserNotificationCenter currentNotificationCenter] getDeliveredNotificationsWithCompletionHandler:^(NSArray<UNNotification *> * _Nonnull notifications) {
-    resolve([self serializeNotifications:notifications]);
-  }];
-}
-
-
-EX_EXPORT_METHOD_AS(dismissNotificationAsync,
-                    dismissNotificationWithIdentifier:(NSString *)identifier
-                    resolve:(EXPromiseResolveBlock)resolve
-                    reject:(EXPromiseRejectBlock)reject)
-{
-  [[UNUserNotificationCenter currentNotificationCenter] removeDeliveredNotificationsWithIdentifiers:@[identifier]];
-  resolve(nil);
-}
-
-EX_EXPORT_METHOD_AS(dismissAllNotificationsAsync,
-                    dismissAllNotificationsWithResolver:(EXPromiseResolveBlock)resolve
-                    reject:(EXPromiseRejectBlock)reject)
-{
-  [[UNUserNotificationCenter currentNotificationCenter] removeAllDeliveredNotifications];
-  resolve(nil);
-}
-
-# pragma mark - EXModuleRegistryConsumer
-
-- (void)setModuleRegistry:(EXModuleRegistry *)moduleRegistry
-{
-  _notificationBuilder = [moduleRegistry getModuleImplementingProtocol:@protocol(EXNotificationBuilder)];
-
-  // Remove once presentNotificationAsync is removed
-  id<EXNotificationCenterDelegate> notificationCenterDelegate = (id<EXNotificationCenterDelegate>)[moduleRegistry getSingletonModuleForName:@"NotificationCenterDelegate"];
-  [notificationCenterDelegate addDelegate:self];
-}
-
-// Remove once presentNotificationAsync is removed
-# pragma mark - EXNotificationsDelegate
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler
-{
-  UNNotificationPresentationOptions presentationOptions = UNNotificationPresentationOptionNone;
-
-  NSString *identifier = notification.request.identifier;
-  if ([_presentedNotifications containsObject:identifier]) {
-    [_presentedNotifications removeObject:identifier];
-    // TODO(iOS 14): use UNNotificationPresentationOptionList and UNNotificationPresentationOptionBanner
-    presentationOptions = UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert | UNNotificationPresentationOptionBadge;
-  }
-
-  completionHandler(presentationOptions);
-}
-
-# pragma mark - Helpers
-
-- (NSArray * _Nonnull)serializeNotifications:(NSArray<UNNotification *> * _Nonnull)notifications
-{
-  NSMutableArray *serializedNotifications = [NSMutableArray new];
-  for (UNNotification *notification in notifications) {
-    [serializedNotifications addObject:[EXNotificationSerializer serializedNotification:notification]];
-  }
-  return serializedNotifications;
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/PresentationModule.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/PresentationModule.swift
new file mode 100644
index 0000000..51c6d4f
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/PresentationModule.swift
@@ -0,0 +1,81 @@
+//  Copyright Â© 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+public class PresentationModule: Module, NotificationDelegate {
+  var presentedNotifications: Set<String> = []
+
+  public func definition() -> ModuleDefinition {
+    Name("ExpoNotificationPresenter")
+
+    OnCreate {
+      NotificationCenterManager.shared.addDelegate(self)
+    }
+
+    OnDestroy {
+      NotificationCenterManager.shared.removeDelegate(self)
+    }
+
+    AsyncFunction("presentNotificationAsync") { (identifier: String, notificationSpec: [String: Any], promise: Promise) in
+      do {
+        guard let appContext = appContext else {
+          let error = NSError(domain: "ExpoNotificationPresenter", code: 0, userInfo: nil)
+          promise.reject("ERR_NOTIF_PRESENT", error.localizedDescription)
+          return
+        }
+        let content = try NotificationBuilder.content(notificationSpec, appContext: appContext)
+        var request: UNNotificationRequest?
+        try EXUtilities.catchException {
+          request = UNNotificationRequest(identifier: identifier, content: content, trigger: nil)
+        }
+        guard let request = request else {
+          promise.reject("ERR_NOTIF_PRESENT", "Notification could not be presented")
+          return
+        }
+        presentedNotifications.insert(identifier)
+        UNUserNotificationCenter.current().add(request) { error in
+          if let error {
+            promise.reject("ERR_NOTIF_PRESENT", error.localizedDescription)
+          } else {
+            promise.resolve()
+          }
+        }
+      } catch {
+        promise.reject("ERR_NOTIF_PRESENT", error.localizedDescription)
+      }
+    }
+    .runOnQueue(.main)
+
+    AsyncFunction("getPresentedNotificationsAsync") { (promise: Promise) in
+      UNUserNotificationCenter.current().getDeliveredNotifications { notifications in
+        promise.resolve(self.serializeNotifications(notifications))
+      }
+    }
+
+    AsyncFunction("dismissNotificationAsync") { (identifier: String) in
+      UNUserNotificationCenter.current().removeDeliveredNotifications(withIdentifiers: [identifier])
+    }
+
+    AsyncFunction("dismissAllNotificationsAsync") {
+      UNUserNotificationCenter.current().removeAllDeliveredNotifications()
+    }
+  }
+
+  public func willPresent(_ notification: UNNotification, completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) -> Bool {
+    let identifier = notification.request.identifier
+    if presentedNotifications.contains(identifier) {
+      presentedNotifications.remove(identifier)
+      completionHandler([.badge, .sound, .banner]) // .alert is deprecated
+      return true
+    }
+    return false
+  }
+
+  func serializeNotifications(_ notifications: [UNNotification]) -> [[AnyHashable: Any]] {
+    return notifications.map { notification in
+      return EXNotificationSerializer.serializedNotification(notification)
+    }
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.h
deleted file mode 100644
index a7fff4c..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.h
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-#import <ExpoModulesCore/EXModuleRegistryConsumer.h>
-#import <UserNotifications/UserNotifications.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@interface EXNotificationSchedulerModule : EXExportedModule <EXModuleRegistryConsumer>
-
-- (NSArray * _Nonnull)serializeNotificationRequests:(NSArray<UNNotificationRequest *> * _Nonnull) requests;
-
-- (void)cancelNotification:(NSString *)identifier resolve:(EXPromiseResolveBlock)resolve rejecting:(EXPromiseRejectBlock)reject;
-
-- (void)cancelAllNotificationsWithResolver:(EXPromiseResolveBlock)resolve rejecting:(EXPromiseRejectBlock)reject;
-
-- (UNNotificationRequest *)buildNotificationRequestWithIdentifier:(NSString *)identifier content:(NSDictionary *)contentInput trigger:(NSDictionary *)triggerInput;
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.m
deleted file mode 100644
index 49e7453..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.m
+++ /dev/null
@@ -1,279 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXNotificationSchedulerModule.h>
-#import <EXNotifications/EXNotificationSerializer.h>
-#import <EXNotifications/EXNotificationBuilder.h>
-#import <EXNotifications/NSDictionary+EXNotificationsVerifyingClass.h>
-
-#import <UserNotifications/UserNotifications.h>
-
-static NSString * const notificationTriggerTypeKey = @"type";
-static NSString * const notificationTriggerRepeatsKey = @"repeats";
-
-static NSString * const intervalNotificationTriggerType = @"timeInterval";
-static NSString * const intervalNotificationTriggerIntervalKey = @"seconds";
-
-static NSString * const dailyNotificationTriggerType = @"daily";
-static NSString * const dailyNotificationTriggerHourKey = @"hour";
-static NSString * const dailyNotificationTriggerMinuteKey = @"minute";
-
-static NSString * const weeklyNotificationTriggerType = @"weekly";
-static NSString * const weeklyNotificationTriggerWeekdayKey = @"weekday";
-static NSString * const weeklyNotificationTriggerHourKey = @"hour";
-static NSString * const weeklyNotificationTriggerMinuteKey = @"minute";
-
-static NSString * const monthlyNotificationTriggerType = @"monthly";
-static NSString * const monthlyNotificationTriggerDayKey = @"day";
-static NSString * const monthlyNotificationTriggerHourKey = @"hour";
-static NSString * const monthlyNotificationTriggerMinuteKey = @"minute";
-
-static NSString * const yearlyNotificationTriggerType = @"yearly";
-static NSString * const yearlyNotificationTriggerDayKey = @"day";
-static NSString * const yearlyNotificationTriggerMonthKey = @"month";
-static NSString * const yearlyNotificationTriggerHourKey = @"hour";
-static NSString * const yearlyNotificationTriggerMinuteKey = @"minute";
-
-static NSString * const dateNotificationTriggerType = @"date";
-static NSString * const dateNotificationTriggerTimestampKey = @"timestamp";
-
-static NSString * const calendarNotificationTriggerType = @"calendar";
-static NSString * const calendarNotificationTriggerComponentsKey = @"value";
-static NSString * const calendarNotificationTriggerTimezoneKey = @"timezone";
-
-
-
-@interface EXNotificationSchedulerModule ()
-
-@property (nonatomic, weak) id<EXNotificationBuilder> builder;
-
-@end
-
-@implementation EXNotificationSchedulerModule
-
-EX_EXPORT_MODULE(ExpoNotificationScheduler);
-
-- (void)setModuleRegistry:(EXModuleRegistry *)moduleRegistry
-{
-  _builder = [moduleRegistry getModuleImplementingProtocol:@protocol(EXNotificationBuilder)];
-}
-
-# pragma mark - Exported methods
-
-EX_EXPORT_METHOD_AS(getAllScheduledNotificationsAsync,
-                    getAllScheduledNotifications:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject
-                    )
-{
-  [[UNUserNotificationCenter currentNotificationCenter] getPendingNotificationRequestsWithCompletionHandler:^(NSArray<UNNotificationRequest *> * _Nonnull requests) {
-    resolve([self serializeNotificationRequests:requests]);
-  }];
-}
-
-EX_EXPORT_METHOD_AS(scheduleNotificationAsync,
-                     scheduleNotification:(NSString *)identifier notificationSpec:(NSDictionary *)notificationSpec triggerSpec:(NSDictionary *)triggerSpec resolve:(EXPromiseResolveBlock)resolve rejecting:(EXPromiseRejectBlock)reject)
-{
-  @try {
-    UNNotificationRequest *request = [self buildNotificationRequestWithIdentifier:identifier content:notificationSpec trigger:triggerSpec];
-    [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {
-      if (error) {
-        NSString *message = [NSString stringWithFormat:@"Failed to schedule notification. %@", error];
-        reject(@"ERR_NOTIFICATIONS_FAILED_TO_SCHEDULE", message, error);
-      } else {
-        resolve(identifier);
-      }
-    }];
-  } @catch (NSException *exception) {
-    NSString *message = [NSString stringWithFormat:@"Failed to schedule notification. %@", exception];
-    reject(@"ERR_NOTIFICATIONS_FAILED_TO_SCHEDULE", message, nil);
-  }
-}
-
-EX_EXPORT_METHOD_AS(cancelScheduledNotificationAsync,
-                     cancelNotification:(NSString *)identifier resolve:(EXPromiseResolveBlock)resolve rejecting:(EXPromiseRejectBlock)reject)
-{
-  [[UNUserNotificationCenter currentNotificationCenter] removePendingNotificationRequestsWithIdentifiers:@[identifier]];
-  resolve(nil);
-}
-
-EX_EXPORT_METHOD_AS(cancelAllScheduledNotificationsAsync,
-                     cancelAllNotificationsWithResolver:(EXPromiseResolveBlock)resolve rejecting:(EXPromiseRejectBlock)reject)
-{
-  [[UNUserNotificationCenter currentNotificationCenter] removeAllPendingNotificationRequests];
-  resolve(nil);
-}
-
-EX_EXPORT_METHOD_AS(getNextTriggerDateAsync,
-                    getNextTriggerDate:(NSDictionary *)triggerSpec resolve:(EXPromiseResolveBlock)resolve rejecting:(EXPromiseRejectBlock)reject)
-{
-  @try {
-    UNNotificationTrigger *trigger = [self triggerFromParams:triggerSpec];
-    if ([trigger isKindOfClass:[UNCalendarNotificationTrigger class]]) {
-      UNCalendarNotificationTrigger *calendarTrigger = (UNCalendarNotificationTrigger *)trigger;
-      NSDate *nextTriggerDate = [calendarTrigger nextTriggerDate];
-      // We want to return milliseconds from this method.
-      resolve(nextTriggerDate ? @([nextTriggerDate timeIntervalSince1970] * 1000) : [NSNull null]);
-    } else if ([trigger isKindOfClass:[UNTimeIntervalNotificationTrigger class]]) {
-      UNTimeIntervalNotificationTrigger *timeIntervalTrigger = (UNTimeIntervalNotificationTrigger *)trigger;
-      NSDate *nextTriggerDate = [timeIntervalTrigger nextTriggerDate];
-      // We want to return milliseconds from this method.
-      resolve(nextTriggerDate ? @([nextTriggerDate timeIntervalSince1970] * 1000) : [NSNull null]);
-    } else {
-      NSString *message = [NSString stringWithFormat:@"It is not possible to get next trigger date for triggers other than calendar-based. Provided trigger resulted in %@ trigger.", NSStringFromClass([trigger class])];
-      reject(@"ERR_NOTIFICATIONS_INVALID_CALENDAR_TRIGGER", message, nil);
-    }
-  } @catch (NSException *exception) {
-    NSString *message = [NSString stringWithFormat:@"Failed to get next trigger date. %@", exception];
-    reject(@"ERR_NOTIFICATIONS_FAILED_TO_GET_NEXT_TRIGGER_DATE", message, nil);
-  }
-}
-
-- (UNNotificationRequest *)buildNotificationRequestWithIdentifier:(NSString *)identifier
-                                                          content:(NSDictionary *)contentInput
-                                                          trigger:(NSDictionary *)triggerInput
-{
-  UNNotificationContent *content = [_builder notificationContentFromRequest:contentInput];
-  UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:identifier content:content trigger:[self triggerFromParams:triggerInput]];
-  return request;
-}
-
-- (NSArray * _Nonnull)serializeNotificationRequests:(NSArray<UNNotificationRequest *> * _Nonnull) requests
-{
-  NSMutableArray *serializedRequests = [NSMutableArray new];
-  for (UNNotificationRequest *request in requests) {
-    [serializedRequests addObject:[EXNotificationSerializer serializedNotificationRequest:request]];
-  }
-  return serializedRequests;
-}
-
-- (UNNotificationTrigger *)triggerFromParams:(NSDictionary *)params
-{
-  if (!params) {
-    // nil trigger is a valid trigger
-    return nil;
-  }
-  if (![params isKindOfClass:[NSDictionary class]]) {
-    NSString *reason = [NSString stringWithFormat:@"Unknown notification trigger declaration passed in, expected a dictionary, received %@.", NSStringFromClass(params.class)];
-    @throw [NSException exceptionWithName:NSInvalidArgumentException reason:reason userInfo:nil];
-  }
-  NSString *triggerType = params[notificationTriggerTypeKey];
-  if ([intervalNotificationTriggerType isEqualToString:triggerType]) {
-    NSNumber *interval = [params objectForKey:intervalNotificationTriggerIntervalKey verifyingClass:[NSNumber class]];
-    NSNumber *repeats = [params objectForKey:notificationTriggerRepeatsKey verifyingClass:[NSNumber class]];
-
-    return [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:[interval unsignedIntegerValue]
-                                                              repeats:[repeats boolValue]];
-  } else if ([dateNotificationTriggerType isEqualToString:triggerType]) {
-    NSNumber *timestampMs = [params objectForKey:dateNotificationTriggerTimestampKey verifyingClass:[NSNumber class]];
-    NSUInteger timestamp = [timestampMs unsignedIntegerValue] / 1000;
-    NSDate *date = [NSDate dateWithTimeIntervalSince1970:timestamp];
-
-    return [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:[date timeIntervalSinceNow]
-                                                              repeats:NO];
-
-  } else if ([dailyNotificationTriggerType isEqualToString:triggerType]) {
-    NSNumber *hour = [params objectForKey:dailyNotificationTriggerHourKey verifyingClass:[NSNumber class]];
-    NSNumber *minute = [params objectForKey:dailyNotificationTriggerMinuteKey verifyingClass:[NSNumber class]];
-    NSDateComponents *dateComponents = [NSDateComponents new];
-    dateComponents.hour = [hour integerValue];
-    dateComponents.minute = [minute integerValue];
-
-    return [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:dateComponents
-                                                                    repeats:YES];
-  } else if ([weeklyNotificationTriggerType isEqualToString:triggerType]) {
-    NSNumber *weekday = [params objectForKey:weeklyNotificationTriggerWeekdayKey verifyingClass:[NSNumber class]];
-    NSNumber *hour = [params objectForKey:weeklyNotificationTriggerHourKey verifyingClass:[NSNumber class]];
-    NSNumber *minute = [params objectForKey:weeklyNotificationTriggerMinuteKey verifyingClass:[NSNumber class]];
-    NSDateComponents *dateComponents = [NSDateComponents new];
-    dateComponents.weekday = [weekday integerValue];
-    dateComponents.hour = [hour integerValue];
-    dateComponents.minute = [minute integerValue];
-
-    return [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:dateComponents
-                                                                    repeats:YES];
-  } else if ([monthlyNotificationTriggerType isEqualToString:triggerType]) {
-    NSNumber *day = [params objectForKey:monthlyNotificationTriggerDayKey verifyingClass:[NSNumber class]];
-    NSNumber *hour = [params objectForKey:monthlyNotificationTriggerHourKey verifyingClass:[NSNumber class]];
-    NSNumber *minute = [params objectForKey:monthlyNotificationTriggerMinuteKey verifyingClass:[NSNumber class]];
-    NSDateComponents *dateComponents = [NSDateComponents new];
-    dateComponents.day = [day integerValue];
-    dateComponents.hour = [hour integerValue];
-    dateComponents.minute = [minute integerValue];
-
-    return [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:dateComponents
-                                                                    repeats:YES];
-  } else if ([yearlyNotificationTriggerType isEqualToString:triggerType]) {
-    NSNumber *day = [params objectForKey:yearlyNotificationTriggerDayKey verifyingClass:[NSNumber class]];
-    NSNumber *month = [params objectForKey:yearlyNotificationTriggerMonthKey verifyingClass:[NSNumber class]];
-    NSNumber *hour = [params objectForKey:yearlyNotificationTriggerHourKey verifyingClass:[NSNumber class]];
-    NSNumber *minute = [params objectForKey:yearlyNotificationTriggerMinuteKey verifyingClass:[NSNumber class]];
-    NSDateComponents *dateComponents = [NSDateComponents new];
-    dateComponents.day = [day integerValue];
-    dateComponents.month = [month integerValue] + 1; // iOS uses 1-12 based numbers for months
-    dateComponents.hour = [hour integerValue];
-    dateComponents.minute = [minute integerValue];
-
-    return [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:dateComponents
-                                                                    repeats:YES];
-  } else if ([calendarNotificationTriggerType isEqualToString:triggerType]) {
-    NSDateComponents *dateComponents = [self dateComponentsFromParams:params[calendarNotificationTriggerComponentsKey]];
-    NSNumber *repeats = [params objectForKey:notificationTriggerRepeatsKey verifyingClass:[NSNumber class]];
-
-    return [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:dateComponents
-                                                                    repeats:[repeats boolValue]];
-  } else {
-    NSString *reason = [NSString stringWithFormat:@"Unknown notification trigger type: %@.", triggerType];
-    @throw [NSException exceptionWithName:NSInvalidArgumentException reason:reason userInfo:nil];
-  }
-}
-
-- (NSDateComponents *)dateComponentsFromParams:(NSDictionary<NSString *, id> *)params
-{
-  NSDateComponents *dateComponents = [NSDateComponents new];
-
-  // TODO: Verify that DoW matches JS getDay()
-  dateComponents.calendar = [NSCalendar calendarWithIdentifier:NSCalendarIdentifierISO8601];
-
-  if ([params objectForKey:calendarNotificationTriggerTimezoneKey verifyingClass:[NSString class]]) {
-    dateComponents.timeZone = [[NSTimeZone alloc] initWithName:params[calendarNotificationTriggerTimezoneKey]];
-  }
-
-  for (NSString *key in [self automatchedDateComponentsKeys]) {
-    if (params[key]) {
-      NSNumber *value = [params objectForKey:key verifyingClass:[NSNumber class]];
-      [dateComponents setValue:[value unsignedIntegerValue] forComponent:[self calendarUnitFor:key]];
-    }
-  }
-
-  return dateComponents;
-}
-
-- (NSDictionary<NSString *, NSNumber *> *)dateComponentsMatchMap
-{
-  static NSDictionary *map;
-  if (!map) {
-    map = @{
-      @"year": @(NSCalendarUnitYear),
-      @"month": @(NSCalendarUnitMonth),
-      @"day": @(NSCalendarUnitDay),
-      @"hour": @(NSCalendarUnitHour),
-      @"minute": @(NSCalendarUnitMinute),
-      @"second": @(NSCalendarUnitSecond),
-      @"weekday": @(NSCalendarUnitWeekday),
-      @"weekOfMonth": @(NSCalendarUnitWeekOfMonth),
-      @"weekOfYear": @(NSCalendarUnitWeekOfYear),
-      @"weekdayOrdinal": @(NSCalendarUnitWeekdayOrdinal)
-    };
-  }
-  return map;
-}
-
-- (NSArray<NSString *> *)automatchedDateComponentsKeys
-{
-  return [[self dateComponentsMatchMap] allKeys];
-}
-
-- (NSCalendarUnit)calendarUnitFor:(NSString *)key
-{
-  return [[self dateComponentsMatchMap][key] unsignedIntegerValue];
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/SchedulerModule.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/SchedulerModule.swift
new file mode 100644
index 0000000..f482a55
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/SchedulerModule.swift
@@ -0,0 +1,302 @@
+//  Copyright Â© 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+// swiftlint:disable identifier_name
+let notificationTriggerTypeKey = "type"
+let notificationTriggerRepeatsKey = "repeats"
+
+let timeIntervalNotificationTriggerType = "timeInterval"
+let dailyNotificationTriggerType = "daily"
+let weeklyNotificationTriggerType = "weekly"
+let monthlyNotificationTriggerType = "monthly"
+let yearlyNotificationTriggerType = "yearly"
+let dateNotificationTriggerType = "date"
+let calendarNotificationTriggerType = "calendar"
+
+let calendarNotificationTriggerComponentsKey = "value"
+let calendarNotificationTriggerTimezoneKey = "timezone"
+// swiftlint:enable identifier_name
+
+let dateComponentsMatchMap: [String: Calendar.Component] = [
+  "year": .year,
+  "month": .month,
+  "day": .day,
+  "hour": .hour,
+  "minute": .minute,
+  "second": .second,
+  "weekday": .weekday,
+  "weekOfMonth": .weekOfMonth,
+  "weekOfYear": .weekOfYear,
+  "weekdayOrdinal": .weekdayOrdinal
+]
+
+struct CalendarTriggerRecord: Record {
+  @Field
+  var year: Int?
+  @Field
+  var month: Int?
+  @Field
+  var day: Int?
+  @Field
+  var hour: Int?
+  @Field
+  var minute: Int?
+  @Field
+  var second: Int?
+  @Field
+  var weekday: Int?
+  @Field
+  var weekOfMonth: Int?
+  @Field
+  var weekOfYear: Int?
+  @Field
+  var weekdayOrdinal: Int?
+  @Field
+  var timezone: String?
+  @Field
+  var repeats: Bool?
+}
+
+struct TimeIntervalTriggerRecord: Record {
+  @Field
+  var seconds: TimeInterval
+  @Field
+  var repeats: Bool
+}
+
+struct DateTriggerRecord: Record {
+  @Field
+  var timestamp: TimeInterval
+}
+
+struct DailyTriggerRecord: Record {
+  @Field
+  var hour: Int
+  @Field
+  var minute: Int
+}
+
+struct WeeklyTriggerRecord: Record {
+  @Field
+  var weekday: Int
+  @Field
+  var hour: Int
+  @Field
+  var minute: Int
+}
+
+struct MonthlyTriggerRecord: Record {
+  @Field
+  var day: Int
+  @Field
+  var hour: Int
+  @Field
+  var minute: Int
+}
+
+struct YearlyTriggerRecord: Record {
+  @Field
+  var month: Int
+  @Field
+  var day: Int
+  @Field
+  var hour: Int
+  @Field
+  var minute: Int
+}
+
+public class SchedulerModule: Module {
+  public func definition() -> ModuleDefinition {
+    Name("ExpoNotificationScheduler")
+
+    AsyncFunction("getAllScheduledNotificationsAsync") { (promise: Promise) in
+      UNUserNotificationCenter.current().getPendingNotificationRequests { (requests: [UNNotificationRequest]) in
+        var serializedRequests: [Any] = []
+        requests.forEach {request in
+          serializedRequests.append(EXNotificationSerializer.serializedNotificationRequest(request))
+        }
+        promise.resolve(serializedRequests)
+      }
+    }
+    .runOnQueue(.main)
+
+    AsyncFunction("cancelScheduledNotificationAsync") { (identifier: String) in
+      UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: [identifier])
+    }
+
+    AsyncFunction("cancelAllScheduledNotificationsAsync") { () in
+      UNUserNotificationCenter.current().removeAllPendingNotificationRequests()
+    }
+
+    AsyncFunction("scheduleNotificationAsync") { (identifier: String, notificationSpec: [String: Any], triggerSpec: [String: Any]?, promise: Promise) in
+      do {
+        guard let request = try buildNotificationRequest(identifier: identifier, contentInput: notificationSpec, triggerInput: triggerSpec) else {
+          promise.reject("ERR_NOTIFICATIONS_FAILED_TO_SCHEDULE", "Failed to build notification request")
+          return
+        }
+        UNUserNotificationCenter.current().add(request) {error in
+          if let error = error {
+            promise.reject("ERR_NOTIFICATIONS_FAILED_TO_SCHEDULE", "Failed to schedule notification, \(error)")
+          } else {
+            promise.resolve()
+          }
+          UNUserNotificationCenter.current().add(request) {error in
+            if let error = error {
+              promise.reject("ERR_NOTIFICATIONS_FAILED_TO_SCHEDULE", "Failed to schedule notification, \(error)")
+            } else {
+              promise.resolve(identifier)
+            }
+          }
+        }
+      } catch {
+        promise.reject("ERR_NOTIFICATIONS_FAILED_TO_SCHEDULE", "Failed to schedule notification, \(error)")
+      }
+    }
+
+    AsyncFunction("getNextTriggerDateAsync") { (triggerSpec: [String: Any], promise: Promise) in
+      guard let appContext = appContext,
+        let trigger = try? triggerFromParams(triggerSpec, appContext: appContext) else {
+        promise.reject("ERR_NOTIFICATIONS_INVALID_CALENDAR_TRIGGER", "Invalid trigger specification")
+        return
+      }
+      if trigger is UNCalendarNotificationTrigger {
+        if let calendarTrigger = trigger as? UNCalendarNotificationTrigger,
+          let nextTriggerDate = calendarTrigger.nextTriggerDate() {
+          promise.resolve(nextTriggerDate.timeIntervalSince1970 * 1000)
+        } else {
+          promise.resolve(nil)
+        }
+        return
+      }
+      if trigger is UNTimeIntervalNotificationTrigger {
+        if let timeIntervalTrigger = trigger as? UNTimeIntervalNotificationTrigger,
+          let nextTriggerDate = timeIntervalTrigger.nextTriggerDate() {
+          promise.resolve(nextTriggerDate.timeIntervalSince1970 * 1000)
+        } else {
+          promise.resolve(nil)
+        }
+        return
+      }
+      promise.reject("ERR_NOTIFICATIONS_INVALID_CALENDAR_TRIGGER", "It is not possible to get next trigger date for triggers other than calendar-based. Provided trigger resulted in \(type(of: trigger)) trigger.")
+    }
+  }
+
+  func triggerFromParams(_ params: [String: Any]?, appContext: AppContext) throws -> UNNotificationTrigger? {
+    guard let params = params else {
+      return nil
+    }
+
+    guard let triggerType = params[notificationTriggerTypeKey] as? String else {
+      return nil
+    }
+
+    switch triggerType {
+    case timeIntervalNotificationTriggerType:
+      let timeIntervalTrigger = try TimeIntervalTriggerRecord(from: params, appContext: appContext)
+      var trigger: UNNotificationTrigger?
+      try EXUtilities.catchException {
+        trigger = UNTimeIntervalNotificationTrigger(timeInterval: timeIntervalTrigger.seconds, repeats: timeIntervalTrigger.repeats)
+      }
+      return trigger
+    case dateNotificationTriggerType:
+      let dateTrigger = try DateTriggerRecord(from: params, appContext: appContext)
+      let timestamp: Int = Int(dateTrigger.timestamp / 1000)
+      let date: Date = Date(timeIntervalSince1970: TimeInterval(timestamp))
+      var trigger: UNNotificationTrigger?
+      try EXUtilities.catchException {
+        trigger = UNTimeIntervalNotificationTrigger(timeInterval: date.timeIntervalSinceNow, repeats: false)
+      }
+      return trigger
+    case dailyNotificationTriggerType:
+      let dailyTrigger = try DailyTriggerRecord(from: params, appContext: appContext)
+      let dateComponents: DateComponents = DateComponents(hour: dailyTrigger.hour, minute: dailyTrigger.minute)
+      var trigger: UNNotificationTrigger?
+      try EXUtilities.catchException {
+        trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)
+      }
+      return trigger
+    case weeklyNotificationTriggerType:
+      let weeklyTrigger = try WeeklyTriggerRecord(from: params, appContext: appContext)
+      let dateComponents: DateComponents = DateComponents(hour: weeklyTrigger.hour, minute: weeklyTrigger.minute, weekday: weeklyTrigger.weekday)
+      var trigger: UNNotificationTrigger?
+      try EXUtilities.catchException {
+        trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)
+      }
+      return trigger
+    case monthlyNotificationTriggerType:
+      let monthlyTrigger = try MonthlyTriggerRecord(from: params, appContext: appContext)
+      let dateComponents: DateComponents = DateComponents(day: monthlyTrigger.day, hour: monthlyTrigger.hour, minute: monthlyTrigger.minute)
+      var trigger: UNNotificationTrigger?
+      try EXUtilities.catchException {
+        trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)
+      }
+      return trigger
+    case yearlyNotificationTriggerType:
+      let yearlyTrigger = try YearlyTriggerRecord(from: params, appContext: appContext)
+      let dateComponents: DateComponents = DateComponents(
+        month: yearlyTrigger.month,
+        day: yearlyTrigger.day,
+        hour: yearlyTrigger.hour,
+        minute: yearlyTrigger.minute
+      )
+      var trigger: UNNotificationTrigger?
+      try EXUtilities.catchException {
+        trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)
+      }
+      return trigger
+    case calendarNotificationTriggerType:
+      let calendarTrigger = try CalendarTriggerRecord(from: params, appContext: appContext)
+      let dateComponents: DateComponents = dateComponentsFrom(calendarTrigger) ?? DateComponents()
+      let repeats = calendarTrigger.repeats ?? false
+      var trigger: UNNotificationTrigger?
+      try EXUtilities.catchException {
+        trigger = UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: repeats)
+      }
+      return trigger
+    default:
+      return nil
+    }
+  }
+
+  func dateComponentsFrom(_ calendarTrigger: CalendarTriggerRecord) -> DateComponents? {
+    var dateComponents = DateComponents()
+    // TODO: Verify that DoW matches JS getDay()
+    dateComponents.calendar = Calendar.init(identifier: .iso8601)
+    if let timeZone = calendarTrigger.timezone {
+      dateComponents.timeZone = TimeZone(identifier: timeZone)
+    }
+    dateComponentsMatchMap.keys.forEach { key in
+      let calendarComponent = dateComponentsMatchMap[key] ?? .day
+      if let value = calendarTrigger.toDictionary()[key] as? Int {
+        dateComponents.setValue(value, for: calendarComponent)
+      }
+    }
+    return dateComponents
+  }
+
+  func serializeNotificationRequests(_ requests: [UNNotificationRequest]) -> [Any] {
+    var serializedRequests: [[AnyHashable: Any]] = []
+    requests.forEach {request in
+      serializedRequests.append(EXNotificationSerializer .serializedNotificationRequest(request))
+    }
+    return serializedRequests
+  }
+
+  func buildNotificationRequest(
+    identifier: String,
+    contentInput: [String: Any],
+    triggerInput: [String: Any]?
+  ) throws -> UNNotificationRequest? {
+    guard let appContext = appContext else {
+      return nil
+    }
+    return try UNNotificationRequest(
+      identifier: identifier,
+      content: NotificationBuilder.content(contentInput, appContext: appContext),
+      trigger: triggerFromParams(triggerInput, appContext: appContext)
+    )
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenAppDelegateSubscriber.swift b/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenAppDelegateSubscriber.swift
index b16f71e..1eba578 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenAppDelegateSubscriber.swift
+++ b/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenAppDelegateSubscriber.swift
@@ -2,22 +2,14 @@ import ExpoModulesCore
 import Foundation
 
 public class PushTokenAppDelegateSubscriber: ExpoAppDelegateSubscriber {
-  public static let ExpoNotificationsRegistrationResult = Notification.Name("ExpoNotificationsRegistrationResult")
+  let notificationCenterManager = NotificationCenterManager.shared
 
   public func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
-    NotificationCenter.default.post(
-      name: PushTokenAppDelegateSubscriber.ExpoNotificationsRegistrationResult,
-      object: nil,
-      userInfo: ["deviceToken": dataToString(deviceToken)]
-    )
+    notificationCenterManager.didRegister(dataToString(deviceToken))
   }
 
   public func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: any Error) {
-    NotificationCenter.default.post(
-      name: PushTokenAppDelegateSubscriber.ExpoNotificationsRegistrationResult,
-      object: nil,
-      userInfo: ["error": error]
-    )
+    notificationCenterManager.didFailRegistration(error)
   }
 }
 
diff --git a/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenModule.swift b/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenModule.swift
index 7b6c5b7..22353c8 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenModule.swift
+++ b/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenModule.swift
@@ -6,46 +6,26 @@ import MachO
 
 let onDevicePushTokenEventName = "onDevicePushToken"
 
-public class PushTokenModule: Module {
+public class PushTokenModule: Module, NotificationDelegate {
   var promiseNotYetResolved: Promise?
 
-  @objc
-  public func onExpoNotificationsRegistrationResult(notification: Notification) {
-    guard let userInfo = notification.userInfo else {
-      return
-    }
-    if let error = userInfo["error"] as? (any Error) {
-      promiseNotYetResolved?.reject(error)
-      promiseNotYetResolved = nil
-    } else if let deviceToken = userInfo["deviceToken"] as? String {
-      promiseNotYetResolved?.resolve(deviceToken)
-      promiseNotYetResolved = nil
-      self.sendEvent(onDevicePushTokenEventName, ["devicePushToken": deviceToken])
-    }
-  }
-
   public func definition() -> ModuleDefinition {
     Name("ExpoPushTokenManager")
 
     Events([onDevicePushTokenEventName])
 
     OnStartObserving(onDevicePushTokenEventName) {
-      NotificationCenter.default.addObserver(
-        self,
-        selector: #selector(onExpoNotificationsRegistrationResult),
-        name: PushTokenAppDelegateSubscriber.ExpoNotificationsRegistrationResult,
-        object: nil
-      )
+      NotificationCenterManager.shared.addDelegate(self)
     }
 
     OnStopObserving(onDevicePushTokenEventName) {
-      // swiftlint:disable:next notification_center_detachment
-      NotificationCenter.default.removeObserver(self)
+      NotificationCenterManager.shared.removeDelegate(self)
     }
 
     AsyncFunction("getDevicePushTokenAsync") { (promise: Promise) in
       if promiseNotYetResolved != nil {
         promise.reject("E_AWAIT_PROMISE", "Another async call to this method is in progress. Await the first Promise.")
+        return
       }
       promiseNotYetResolved = promise
       UIApplication.shared.registerForRemoteNotifications()
@@ -57,4 +37,15 @@ public class PushTokenModule: Module {
     }
     .runOnQueue(.main)
   }
+
+  public func didRegister(_ deviceToken: String) {
+    promiseNotYetResolved?.resolve(deviceToken)
+    promiseNotYetResolved = nil
+    self.sendEvent(onDevicePushTokenEventName, ["devicePushToken": deviceToken])
+  }
+
+  public func didFailRegistration(_ error: any Error) {
+    promiseNotYetResolved?.reject(error)
+    promiseNotYetResolved = nil
+  }
 }
