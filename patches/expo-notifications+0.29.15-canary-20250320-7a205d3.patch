diff --git a/node_modules/expo-notifications/expo-module.config.json b/node_modules/expo-notifications/expo-module.config.json
index a335999..faf4728 100644
--- a/node_modules/expo-notifications/expo-module.config.json
+++ b/node_modules/expo-notifications/expo-module.config.json
@@ -2,8 +2,11 @@
   "platforms": ["apple", "android"],
   "apple": {
     "modules": [
+      "BackgroundModule",
       "BadgeModule",
       "CategoriesModule",
+      "HandlerModule",
+      "EmitterModule",
       "PresentationModule",
       "PushTokenModule",
       "ServerRegistrationModule",
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/BackgroundModule.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/BackgroundModule.swift
new file mode 100644
index 0000000..f55c073
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/BackgroundModule.swift
@@ -0,0 +1,47 @@
+//  Copyright © 2025 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+public class BackgroundModule: Module {
+  var taskManager: EXTaskManagerInterface?
+
+  public func definition() -> ModuleDefinition {
+    Name("ExpoBackgroundNotificationTasksModule")
+
+    OnCreate {
+      taskManager = appContext?.legacyModule(implementing: EXTaskManagerInterface.self)
+    }
+
+    AsyncFunction("registerTaskAsync") {(name: String, promise: Promise) in
+      guard let taskManager else {
+        promise.reject(
+          "E_BACKGROUND_REMOTE_NOTIFICATIONS_DISABLED",
+          "TaskManager not found. Are you sure that Expo modules are properly linked?"
+        )
+        return
+      }
+
+      if !taskManager.hasBackgroundModeEnabled("remote-notification") {
+        promise.reject(
+          "E_BACKGROUND_REMOTE_NOTIFICATIONS_DISABLED",
+          "Background remote notifications have not been configured. " +
+          "To enable it, set the `enableBackgroundRemoteNotifications` parameter " +
+          "in the expo-notifications config plugin, or add `remote-notification` to " +
+          "`UIBackgroundModes` in the application's Info.plist file."
+        )
+        return
+      }
+
+      taskManager.registerTask(withName: name, consumer: NotificationsBackgroundTaskConsumer.self, options: [:])
+
+      promise.resolve(nil)
+    }
+
+    AsyncFunction("unregisterTaskAsync") {(name: String, promise: Promise) in
+      taskManager?.unregisterTask(withName: name, consumerClass: NotificationsBackgroundTaskConsumer.self)
+      promise.resolve(nil)
+    }
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/EXBackgroundNotificationTasksModule.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/EXBackgroundNotificationTasksModule.h
deleted file mode 100644
index d68c4b8..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/EXBackgroundNotificationTasksModule.h
+++ /dev/null
@@ -1,16 +0,0 @@
-// Copyright 2021-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-#import <ExpoModulesCore/EXModuleRegistryConsumer.h>
-#import <EXNotifications/EXNotificationsDelegate.h>
-
-typedef NS_ENUM(NSUInteger, EXBackgroundNotificationResult) {
-  EXBackgroundNotificationResultNoData = 1,
-  EXBackgroundNotificationResultNewData = 2,
-  EXBackgroundNotificationResultFailed = 3,
-};
-
-@interface EXBackgroundNotificationTasksModule : EXExportedModule <EXModuleRegistryConsumer>
-
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/EXBackgroundNotificationTasksModule.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/EXBackgroundNotificationTasksModule.m
deleted file mode 100644
index 967e528..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/EXBackgroundNotificationTasksModule.m
+++ /dev/null
@@ -1,62 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXBackgroundNotificationTasksModule.h>
-#import <EXNotifications/EXBackgroundRemoteNotificationConsumer.h>
-#import <ExpoModulesCore/EXTaskManagerInterface.h>
-
-@interface EXBackgroundNotificationTasksModule ()
-
-@property (nonatomic, weak) id<EXTaskManagerInterface> taskManager;
-
-@end
-
-@implementation EXBackgroundNotificationTasksModule
-
-EX_EXPORT_MODULE(ExpoBackgroundNotificationTasksModule);
-
-# pragma mark - EXModuleRegistryConsumer
-
-- (void)setModuleRegistry:(EXModuleRegistry *)moduleRegistry
-{
-  _taskManager = [moduleRegistry getModuleImplementingProtocol:@protocol(EXTaskManagerInterface)];
-}
-# pragma mark - Exported methods
-
-EX_EXPORT_METHOD_AS(registerTaskAsync,
-                    registerTaskWithName:(nonnull NSString *)taskName
-                    resolve:(EXPromiseResolveBlock)resolve
-                    reject:(EXPromiseRejectBlock)reject)
-{
-  if (![_taskManager hasBackgroundModeEnabled:@"remote-notification"]) {
-    return reject(
-                  @"E_BACKGROUND_REMOTE_NOTIFICATIONS_DISABLED",
-                  @"Background remote notifications have not been configured. To enable it, add `remote-notification` to `UIBackgroundModes` in the application's Info.plist file.",
-                  nil
-                  );
-  }
-
-  @try {
-    [_taskManager registerTaskWithName:taskName
-                              consumer:EXBackgroundRemoteNotificationConsumer.class
-                               options:@{}];
-  }
-  @catch (NSException *e) {
-    return reject(e.name, e.reason, nil);
-  }
-  resolve(nil);
-}
-
-EX_EXPORT_METHOD_AS(unregisterTaskAsync,
-                    unregisterTaskWithName:(nonnull NSString *)taskName
-                    resolve:(EXPromiseResolveBlock)resolve
-                    reject:(EXPromiseRejectBlock)reject)
-{
-  @try {
-    [_taskManager unregisterTaskWithName:taskName consumerClass:[EXBackgroundRemoteNotificationConsumer class]];
-  } @catch (NSException *e) {
-    return reject(e.name, e.reason, nil);
-  }
-  resolve(nil);
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/EXBackgroundRemoteNotificationConsumer.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/EXBackgroundRemoteNotificationConsumer.h
deleted file mode 100644
index cab7d73..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/EXBackgroundRemoteNotificationConsumer.h
+++ /dev/null
@@ -1,14 +0,0 @@
-// Copyright 2021-present 650 Industries. All rights reserved.
-
-#import <Foundation/Foundation.h>
-#import <ExpoModulesCore/EXTaskConsumerInterface.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@interface EXBackgroundRemoteNotificationConsumer : NSObject <EXTaskConsumerInterface>
-
-@property (nonatomic, strong) id<EXTaskInterface> task;
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/EXBackgroundRemoteNotificationConsumer.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/EXBackgroundRemoteNotificationConsumer.m
deleted file mode 100644
index 1318c8a..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/EXBackgroundRemoteNotificationConsumer.m
+++ /dev/null
@@ -1,51 +0,0 @@
-// Copyright 2021-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXBackgroundNotificationTasksModule.h>
-#import <EXNotifications/EXBackgroundRemoteNotificationConsumer.h>
-#import <ExpoModulesCore/EXTaskInterface.h>
-
-@implementation EXBackgroundRemoteNotificationConsumer
-
-+ (BOOL)supportsLaunchReason:(EXTaskLaunchReason)launchReason
-{
-  return launchReason == EXTaskLaunchReasonRemoteNotification;
-}
-
-- (NSString *)taskType
-{
-  return @"remote-notification";
-}
-
-// Associating task to the consumer.
-- (void)didRegisterTask:(id<EXTaskInterface>)task
-{
-  _task = task;
-}
-
-// Method that is being called when the JS app just finished launching,
-// after the native app was launched with the launch reason supported by the consumer.
-// For background notifications, `application:didReceiveRemoteNotification:fetchCompletionHandler:` is the entry point of this method,
-// so the task can be executed immediately here
-- (void)didBecomeReadyToExecuteWithData:(NSDictionary *)data
-{
-  [_task executeWithData:data withError:nil];
-}
-
-// Translate result received from JS to another (native) type that is then used for example as an argument in completion callbacks.
-- (NSUInteger)normalizeTaskResult:(id)result
-{
-  if (!result || result == [NSNull null]) {
-    return UIBackgroundFetchResultNoData;
-  }
-  switch ([result unsignedIntegerValue]) {
-    case EXBackgroundNotificationResultNewData:
-      return UIBackgroundFetchResultNewData;
-    case EXBackgroundNotificationResultFailed:
-      return UIBackgroundFetchResultFailed;
-    case EXBackgroundNotificationResultNoData:
-    default:
-      return UIBackgroundFetchResultNoData;
-  }
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/NotificationsBackgroundTaskConsumer.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/NotificationsBackgroundTaskConsumer.swift
new file mode 100644
index 0000000..c6cc6ce
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Background/NotificationsBackgroundTaskConsumer.swift
@@ -0,0 +1,47 @@
+// Copyright 2024-present 650 Industries. All rights reserved.
+import ExpoModulesCore
+
+class NotificationsBackgroundTaskConsumer: NSObject, EXTaskConsumerInterface {
+  var task: EXTaskInterface?
+
+  static func supportsLaunchReason(_ launchReason: EXTaskLaunchReason) -> Bool {
+    return launchReason == EXTaskLaunchReasonRemoteNotification
+  }
+
+  func taskType() -> String {
+    return "remote-notification"
+  }
+
+  func normalizeTaskResult(_ result: Any?) -> UInt {
+    guard let result = result as? Int else {
+      return UIBackgroundFetchResult.noData.rawValue
+    }
+
+    switch result {
+    case BackgroundNotificationResult.newData.rawValue:
+      return UIBackgroundFetchResult.newData.rawValue
+    case BackgroundNotificationResult.failed.rawValue:
+      return UIBackgroundFetchResult.failed.rawValue
+    default:
+      return UIBackgroundFetchResult.noData.rawValue
+    }
+  }
+
+  func didBecomeReadyToExecute(withData data: [AnyHashable: Any]?) {
+    self.task?.execute(withData: data, withError: nil)
+  }
+
+  func didRegisterTask(_ task: EXTaskInterface) {
+    self.task = task
+  }
+
+  func didUnregister() {
+    self.task = nil
+  }
+}
+
+enum BackgroundNotificationResult: Int, Enumerable {
+  case noData = 1
+  case newData = 2
+  case failed = 3
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.h
deleted file mode 100644
index d3423bf..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.h
+++ /dev/null
@@ -1,34 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <Foundation/Foundation.h>
-#import <UIKit/UIKit.h>
-#import <ExpoModulesCore/EXSingletonModule.h>
-#import <UserNotifications/UserNotifications.h>
-#import <EXNotifications/EXNotificationsDelegate.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@protocol EXNotificationCenterDelegate
-
-- (void)addDelegate:(id<EXNotificationsDelegate>)delegate;
-- (void)removeDelegate:(id<EXNotificationsDelegate>)delegate;
-- (nullable UNNotificationResponse *)lastNotificationResponse;
-- (void)setLastNotificationResponse:(nullable UNNotificationResponse *)response;
-
-@end
-
-@interface EXNotificationCenterDelegate : EXSingletonModule <UIApplicationDelegate, UNUserNotificationCenterDelegate, EXNotificationCenterDelegate>
-
-- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(nullable NSDictionary<UIApplicationLaunchOptionsKey,id> *)launchOptions;
-- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler;
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler;
-/*
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler;
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center openSettingsForNotification:(nullable UNNotification *)notification;
- */
-@property (nonatomic, strong, nullable) UNNotificationResponse *lastNotificationResponse;
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.m
deleted file mode 100644
index 10c3997..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.m
+++ /dev/null
@@ -1,190 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXNotificationCenterDelegate.h>
-#import <ExpoModulesCore/EXDefines.h>
-#import <EXNotifications/EXNotificationsDelegate.h>
-
-#if __has_include(<EXNotifications/EXNotifications-Swift.h>)
-#import <EXNotifications/EXNotifications-Swift.h>
-#else
-#import "EXNotifications-Swift.h"
-#endif
-
-@interface EXNotificationCenterDelegate ()
-
-@property (nonatomic, strong) NSPointerArray *delegates;
-@property (nonatomic, strong) NSMutableArray<UNNotificationResponse *> *pendingNotificationResponses;
-@property (nonatomic, weak) EXNotificationCenterManager *notificationCenterManager;
-
-@end
-
-@implementation EXNotificationCenterDelegate
-
-EX_REGISTER_SINGLETON_MODULE(NotificationCenterDelegate);
-
-- (instancetype)init
-{
-  if (self = [super init]) {
-    _delegates = [NSPointerArray weakObjectsPointerArray];
-    _pendingNotificationResponses = [NSMutableArray array];
-    _notificationCenterManager = [EXNotificationCenterManager shared];
-  }
-  return self;
-}
-
-# pragma mark - UIApplicationDelegate
-
-- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary<UIApplicationLaunchOptionsKey,id> *)launchOptions
-{
-  if ([UNUserNotificationCenter currentNotificationCenter].delegate) {
-    EXLogWarn(@"[expo-notifications] EXNotificationCenterDelegate encountered already present delegate of UNUserNotificationCenter: %@. "
-              "EXNotificationCenterDelegate will not overwrite the value not to break other features of your app. "
-              "In return, expo-notifications may not work properly. "
-              "To fix this problem either remove setting of the second delegate "
-              "or set the delegate to an instance of EXNotificationCenterDelegate manually afterwards.",
-              [UNUserNotificationCenter currentNotificationCenter].delegate);
-    return YES;
-  }
-
-  [[UNUserNotificationCenter currentNotificationCenter] setDelegate:self];
-  return YES;
-}
-
-- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
-{
-  __block int delegatesCalled = 0;
-  __block int delegatesCompleted = 0;
-  __block BOOL delegatingCompleted = NO;
-  __block BOOL delegatesFailed = 0;
-  __block UIBackgroundFetchResult resultSum = UIBackgroundFetchResultNoData;
-  __block void (^completionHandlerCaller)(void) = ^{
-    if (delegatingCompleted && delegatesCompleted == delegatesCalled) {
-      if (delegatesCompleted == delegatesFailed) {
-        // If all delegates failed to fetch result, let's let the OS know about that
-        completionHandler(UIBackgroundFetchResultFailed);
-      } else {
-        // If at least one succeeded, let's take it as read and respond with that result.
-        completionHandler(resultSum);
-      }
-    }
-  };
-
-  for (int i = 0; i < _delegates.count; i++) {
-    id pointer = [_delegates pointerAtIndex:i];
-    if ([pointer respondsToSelector:@selector(application:didReceiveRemoteNotification:fetchCompletionHandler:)]) {
-      [pointer application:application didReceiveRemoteNotification:userInfo fetchCompletionHandler:^(UIBackgroundFetchResult result) {
-        @synchronized (self) {
-          if (result == UIBackgroundFetchResultFailed) {
-            delegatesFailed += 1;
-          } else if (result == UIBackgroundFetchResultNewData) {
-            resultSum = UIBackgroundFetchResultNewData;
-          }
-          delegatesCompleted += 1;
-          completionHandlerCaller();
-        }
-      }];
-      @synchronized (self) {
-        delegatesCalled += 1;
-      }
-    }
-  }
-  @synchronized (self) {
-    delegatingCompleted = YES;
-    completionHandlerCaller();
-  }
-}
-
-# pragma mark - UNUserNotificationCenterDelegate
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler
-{
-  // Delegate to the new Swift code
-  [_notificationCenterManager userNotificationCenter:center willPresentNotification:notification withCompletionHandler:completionHandler];
-}
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler
-{
-  // Save last response here for use by EXNotificationsEmitter
-  self.lastNotificationResponse = response;
-  // Save response to pending responses array if none of the handlers will handle it.
-  BOOL responseWillBeHandledByAppropriateDelegate = NO;
-  for (int i = 0; i < _delegates.count; i++) {
-    id pointer = [_delegates pointerAtIndex:i];
-    if ([pointer respondsToSelector:@selector(userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler:)]) {
-      responseWillBeHandledByAppropriateDelegate = YES;
-      break;
-    }
-  }
-  if (!responseWillBeHandledByAppropriateDelegate) {
-    [_pendingNotificationResponses addObject:response];
-  }
-
-  __block int delegatesCalled = 0;
-  __block int delegatesCompleted = 0;
-  __block BOOL delegatingCompleted = NO;
-  void (^completionHandlerCaller)(void) = ^{
-    if (delegatingCompleted && delegatesCompleted == delegatesCalled) {
-      completionHandler();
-    }
-  };
-
-  for (int i = 0; i < _delegates.count; i++) {
-    id pointer = [_delegates pointerAtIndex:i];
-    if ([pointer respondsToSelector:@selector(userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler:)]) {
-      [pointer userNotificationCenter:center didReceiveNotificationResponse:response withCompletionHandler:^{
-        @synchronized (self) {
-          delegatesCompleted += 1;
-          completionHandlerCaller();
-        }
-      }];
-      @synchronized (self) {
-        delegatesCalled += 1;
-      }
-    }
-  }
-  @synchronized (self) {
-    delegatingCompleted = YES;
-    completionHandlerCaller();
-  }
-}
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center openSettingsForNotification:(UNNotification *)notification
-{
-  // Delegate to the new Swift manager
-  [_notificationCenterManager userNotificationCenter:center openSettingsForNotification:notification];
-}
-
-# pragma mark - EXNotificationCenterDelegate
-
-- (void)addDelegate:(id<EXNotificationsDelegate>)delegate
-{
-  [_delegates addPointer:(__bridge void * _Nullable)(delegate)];
-  if ([delegate respondsToSelector:@selector(userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler:)]) {
-    UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];
-
-    NSArray *responsesToProcess = [_pendingNotificationResponses copy];
-    [_pendingNotificationResponses removeAllObjects];
-
-    for (UNNotificationResponse *response in responsesToProcess) {
-      [delegate userNotificationCenter:center didReceiveNotificationResponse:response withCompletionHandler:^{
-        // completion handler doesn't need to do anything
-      }];
-    }
-  }
-}
-
-- (void)removeDelegate:(id<EXNotificationsDelegate>)delegate
-{
-  for (int i = 0; i < _delegates.count; i++) {
-    id pointer = [_delegates pointerAtIndex:i];
-    if (pointer == (__bridge void * _Nullable)(delegate) || !pointer) {
-      [_delegates removePointerAtIndex:i];
-      i--;
-    }
-  }
-  // compact doesn't work, that's why we need the `|| !pointer` above
-  // http://www.openradar.me/15396578
-  [_delegates compact];
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.h
index 14e35d3..12a72cb 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.h
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.h
@@ -6,10 +6,10 @@ NS_ASSUME_NONNULL_BEGIN
 
 @interface EXNotificationSerializer : NSObject
 
-+ (NSDictionary *)serializedNotification:(UNNotification *)notification;
-+ (NSDictionary *)serializedNotificationRequest:(UNNotificationRequest *)notificationRequest;
-+ (NSDictionary *)serializedNotificationResponse:(UNNotificationResponse *)notificationResponse;
-+ (NSDictionary *)serializedNotificationContent:(UNNotificationRequest *)request;
++ (NSDictionary<NSString *, NSObject *> *)serializedNotification:(UNNotification *)notification;
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationRequest:(UNNotificationRequest *)notificationRequest;
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationResponse:(UNNotificationResponse *)notificationResponse;
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationContent:(UNNotificationRequest *)request;
 
 @end
 
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.m
index 1c5bdd0..2372751 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.m
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationSerializer.m
@@ -9,7 +9,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
 
 @implementation EXNotificationSerializer
 
-+ (NSDictionary *)serializedNotificationResponse:(UNNotificationResponse *)response
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationResponse:(UNNotificationResponse *)response
 {
   NSMutableDictionary *serializedResponse = [NSMutableDictionary dictionary];
   NSString *actionIdentifier = response.actionIdentifier;
@@ -25,7 +25,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return serializedResponse;
 }
 
-+ (NSDictionary *)serializedNotification:(UNNotification *)notification
++ (NSDictionary<NSString *, NSObject *> *)serializedNotification:(UNNotification *)notification
 {
   NSMutableDictionary *serializedNotification = [NSMutableDictionary dictionary];
   serializedNotification[@"request"] = [self serializedNotificationRequest:notification.request];
@@ -33,16 +33,16 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return serializedNotification;
 }
 
-+ (NSDictionary *)serializedNotificationRequest:(UNNotificationRequest *)request
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationRequest:(UNNotificationRequest *)request
 {
   NSMutableDictionary *serializedRequest = [NSMutableDictionary dictionary];
   serializedRequest[@"identifier"] = request.identifier;
   serializedRequest[@"content"] = [self serializedNotificationContent:request];
-  serializedRequest[@"trigger"] = [self serializedNotificationTrigger:request];
+  serializedRequest[@"trigger"] = request.trigger ? [self serializedNotificationTrigger:request] : [NSNull null];
   return serializedRequest;
 }
 
-+ (NSDictionary *)serializedNotificationContent:(UNNotificationRequest *)request
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationContent:(UNNotificationRequest *)request
 {
   UNNotificationContent *content = request.content;
   NSMutableDictionary *serializedContent = [NSMutableDictionary dictionary];
@@ -76,7 +76,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return [interruptionLevelMap objectForKey:@(interruptionLevel)];
 }
 
-+ (NSDictionary *)serializedNotificationData:(UNNotificationRequest *)request
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationData:(UNNotificationRequest *)request
 {
   BOOL isRemote = [request.trigger isKindOfClass:[UNPushNotificationTrigger class]];
   return isRemote ? request.content.userInfo[@"body"] : request.content.userInfo;
@@ -109,7 +109,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return serializedAttachments;
 }
 
-+ (NSDictionary *)serializedNotificationAttachment:(UNNotificationAttachment *)attachment
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationAttachment:(UNNotificationAttachment *)attachment
 {
   NSMutableDictionary *serializedAttachment = [NSMutableDictionary dictionary];
   serializedAttachment[@"identifier"] = attachment.identifier ?: [NSNull null];
@@ -118,7 +118,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return serializedAttachment;
 }
 
-+ (NSDictionary *)serializedNotificationTrigger:(UNNotificationRequest *)request
++ (NSDictionary<NSString *, NSObject *> *)serializedNotificationTrigger:(UNNotificationRequest *)request
 {
   UNNotificationTrigger *trigger = request.trigger;
   NSMutableDictionary *serializedTrigger = [NSMutableDictionary dictionary];
@@ -149,7 +149,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return serializedTrigger;
 }
 
-+ (NSDictionary *)serializedDateComponents:(NSDateComponents *)dateComponents
++ (NSDictionary<NSString *, NSObject *> *)serializedDateComponents:(NSDateComponents *)dateComponents
 {
   NSMutableDictionary *serializedComponents = [NSMutableDictionary dictionary];
   NSArray<NSNumber *> *autoConvertedUnits = [[self calendarUnitsConversionMap] allKeys];
@@ -197,7 +197,7 @@ static NSString * const EXNotificationResponseDefaultActionIdentifier = @"expo.m
   return [self calendarUnitsConversionMap][@(calendarUnit)];
 }
 
-+ (NSDictionary *)serializedRegion:(CLRegion *)region
++ (NSDictionary<NSString *, NSObject *> *)serializedRegion:(CLRegion *)region
 {
   NSMutableDictionary *serializedRegion = [NSMutableDictionary dictionary];
   serializedRegion[@"identifier"] = region.identifier;
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationsDelegate.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationsDelegate.h
deleted file mode 100644
index e20ca83..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/EXNotificationsDelegate.h
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <Foundation/Foundation.h>
-#import <UIKit/UIKit.h>
-#import <UserNotifications/UserNotifications.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@protocol EXNotificationsDelegate <NSObject>
-
-@optional
-
-# pragma mark - UIApplicationDelegate
-
-- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler;
-
-# pragma mark - UNUserNotificationCenterDelegate
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler;
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler;
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center openSettingsForNotification:(UNNotification *)notification;
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EXNotificationsEmitter.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EXNotificationsEmitter.h
deleted file mode 100644
index 3590bf1..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EXNotificationsEmitter.h
+++ /dev/null
@@ -1,18 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-#import <ExpoModulesCore/EXEventEmitter.h>
-#import <ExpoModulesCore/EXModuleRegistryConsumer.h>
-#import <ExpoModulesCore/EXEventEmitterService.h>
-
-#import <EXNotifications/EXNotificationsDelegate.h>
-
-static NSString * const onDidReceiveNotification = @"onDidReceiveNotification";
-static NSString * const onDidReceiveNotificationResponse = @"onDidReceiveNotificationResponse";
-static NSString * const onDidClearNotificationResponse = @"onDidClearNotificationResponse";
-
-@interface EXNotificationsEmitter : EXExportedModule <EXEventEmitter, EXModuleRegistryConsumer, EXNotificationsDelegate>
-
-@property (nonatomic, weak, readonly) id<EXEventEmitterService> eventEmitter;
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EXNotificationsEmitter.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EXNotificationsEmitter.m
deleted file mode 100644
index 7d46d62..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EXNotificationsEmitter.m
+++ /dev/null
@@ -1,120 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXNotificationsEmitter.h>
-#import <EXNotifications/EXNotificationSerializer.h>
-#import <EXNotifications/EXNotificationCenterDelegate.h>
-
-#import <ExpoModulesCore/EXEventEmitterService.h>
-
-@interface EXNotificationsEmitter ()
-
-@property (nonatomic, weak) id<EXNotificationCenterDelegate> notificationCenterDelegate;
-
-@property (nonatomic, assign) BOOL isBeingObserved;
-@property (nonatomic, assign) BOOL isListening;
-
-@property (nonatomic, weak) id<EXEventEmitterService> eventEmitter;
-
-@end
-
-@implementation EXNotificationsEmitter
-
-EX_EXPORT_MODULE(ExpoNotificationsEmitter);
-
-EX_EXPORT_METHOD_AS(getLastNotificationResponseAsync,
-                    getLastNotificationResponseAsyncWithResolver:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject)
-{
-  UNNotificationResponse* lastResponse = _notificationCenterDelegate.lastNotificationResponse;
-  resolve(lastResponse ? [self serializedNotificationResponse:lastResponse] : [NSNull null]);
-}
-
-EX_EXPORT_METHOD_AS(clearLastNotificationResponseAsync,
-                    clearLastNotificationResponseAsyncWithResolver:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject)
-{
-  _notificationCenterDelegate.lastNotificationResponse = nil;
-  resolve([NSNull null]);
-}
-
-# pragma mark - EXModuleRegistryConsumer
-
-- (void)setModuleRegistry:(EXModuleRegistry *)moduleRegistry
-{
-  _eventEmitter = [moduleRegistry getModuleImplementingProtocol:@protocol(EXEventEmitterService)];
-  _notificationCenterDelegate = [moduleRegistry getSingletonModuleForName:@"NotificationCenterDelegate"];
-}
-
-# pragma mark - EXEventEmitter
-
-- (NSArray<NSString *> *)supportedEvents
-{
-  return @[onDidReceiveNotification, onDidReceiveNotificationResponse, onDidClearNotificationResponse];
-}
-
-- (void)startObserving
-{
-  [self setIsBeingObserved:YES];
-}
-
-- (void)stopObserving
-{
-  [self setIsBeingObserved:NO];
-}
-
-- (void)setIsBeingObserved:(BOOL)isBeingObserved
-{
-  _isBeingObserved = isBeingObserved;
-  BOOL shouldListen = _isBeingObserved;
-  if (shouldListen && !_isListening) {
-    [_notificationCenterDelegate addDelegate:self];
-    _isListening = YES;
-  } else if (!shouldListen && _isListening) {
-    [_notificationCenterDelegate removeDelegate:self];
-    _isListening = NO;
-  }
-}
-
-# pragma mark - EXNotificationsDelegate
-
-- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler
-{
-  // Background task execution would happen here.
-  completionHandler(UIBackgroundFetchResultNoData);
-}
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)(void))completionHandler
-{
-  _notificationCenterDelegate.lastNotificationResponse = response;
-  [self sendEventWithName:onDidReceiveNotificationResponse body:[self serializedNotificationResponse:response]];
-  completionHandler();
-}
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler
-{
-  [self sendEventWithName:onDidReceiveNotification body:[self serializedNotification:notification]];
-  completionHandler(UNNotificationPresentationOptionNone);
-}
-
-- (void)sendEventWithName:(NSString *)eventName body:(id)body
-{
-  // Silence React Native warning: "Sending ... with no listeners registered."
-  // See: https://github.com/expo/expo/pull/10883#pullrequestreview-529183413
-  // While in practice we don't need to verify this, as as of the end of 2020
-  // we wouldn't send any event to JS if we weren't being observed because
-  // we wouldn't be subscribed to the notification center delegate it's nice
-  // to be sure this problem won't ever arise.
-  if (_isBeingObserved) {
-    [_eventEmitter sendEventWithName:eventName body:body];
-  }
-}
-
-- (NSDictionary *)serializedNotification:(UNNotification *)notification
-{
-  return [EXNotificationSerializer serializedNotification:notification];
-}
-
-- (NSDictionary *)serializedNotificationResponse:(UNNotificationResponse *)notificationResponse
-{
-  return [EXNotificationSerializer serializedNotificationResponse:notificationResponse];
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EmitterModule.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EmitterModule.swift
new file mode 100644
index 0000000..6ea5b52
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Emitter/EmitterModule.swift
@@ -0,0 +1,59 @@
+//  Copyright © 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+let onDidReceiveNotification = "onDidReceiveNotification"
+let onDidReceiveNotificationResponse = "onDidReceiveNotificationResponse"
+let onDidClearNotificationResponse = "onDidClearNotificationResponse"
+
+public class EmitterModule: Module, NotificationDelegate {
+  public func definition() -> ModuleDefinition {
+    Name("ExpoNotificationsEmitter")
+
+    Events([onDidReceiveNotification, onDidReceiveNotificationResponse, onDidClearNotificationResponse])
+
+    OnStartObserving {
+      NotificationCenterManager.shared.addDelegate(self)
+    }
+
+    OnStopObserving {
+      NotificationCenterManager.shared.removeDelegate(self)
+    }
+
+    AsyncFunction("getLastNotificationResponseAsync") {(promise: Promise) in
+      if let lastResponse: UNNotificationResponse = NotificationCenterManager.shared.lastResponse {
+        promise.resolve(EXNotificationSerializer.serializedNotificationResponse(lastResponse))
+      }
+      promise.resolve(nil)
+    }
+
+    AsyncFunction("clearLastNotificationResponseAsync") {(promise: Promise) in
+      NotificationCenterManager.shared.lastResponse = nil
+      promise.resolve(nil)
+    }
+  }
+
+  public func didReceive(_ userInfo: [AnyHashable: Any], completionHandler: @escaping (UIBackgroundFetchResult) -> Void) -> Bool {
+    completionHandler(.noData)
+    return true
+  }
+
+  public func didReceive(_ response: UNNotificationResponse, completionHandler: @escaping () -> Void) -> Bool {
+    NotificationCenterManager.shared.lastResponse = response
+    // TODO: convert serialization to Records
+    let serializedResponse = EXNotificationSerializer.serializedNotificationResponse(response)
+    self.sendEvent(onDidReceiveNotificationResponse, serializedResponse as [String: Any])
+    completionHandler()
+    return true
+  }
+
+  public func willPresent(_ notification: UNNotification, completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) -> Bool {
+    // TODO: convert serialization to Records
+    let serializedNotification = EXNotificationSerializer.serializedNotification(notification)
+    self.sendEvent(onDidReceiveNotification, serializedNotification as [String: Any])
+    completionHandler([])
+    return true
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXNotificationsHandlerModule.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXNotificationsHandlerModule.h
deleted file mode 100644
index a8536c0..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXNotificationsHandlerModule.h
+++ /dev/null
@@ -1,12 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-#import <ExpoModulesCore/EXEventEmitter.h>
-#import <ExpoModulesCore/EXModuleRegistryConsumer.h>
-
-#import <EXNotifications/EXNotificationsDelegate.h>
-#import <EXNotifications/EXSingleNotificationHandlerTask.h>
-
-@interface EXNotificationsHandlerModule : EXExportedModule <EXEventEmitter, EXModuleRegistryConsumer, EXNotificationsDelegate, EXSingleNotificationHandlerTaskDelegate>
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXNotificationsHandlerModule.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXNotificationsHandlerModule.m
deleted file mode 100644
index e20e6e8..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXNotificationsHandlerModule.m
+++ /dev/null
@@ -1,109 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXNotificationsHandlerModule.h>
-#import <EXNotifications/EXNotificationSerializer.h>
-#import <EXNotifications/EXNotificationCenterDelegate.h>
-
-#import <ExpoModulesCore/EXEventEmitterService.h>
-
-@interface EXNotificationsHandlerModule ()
-
-@property (nonatomic, weak) id<EXNotificationCenterDelegate> notificationCenterDelegate;
-
-@property (nonatomic, assign) BOOL isListening;
-@property (nonatomic, assign) BOOL isBeingObserved;
-
-@property (nonatomic, weak) id<EXEventEmitterService> eventEmitter;
-
-@property (nonatomic, strong) NSMutableDictionary<NSString *, EXSingleNotificationHandlerTask *> *tasksMap;
-
-@end
-
-@implementation EXNotificationsHandlerModule
-
-EX_EXPORT_MODULE(ExpoNotificationsHandlerModule);
-
-- (instancetype)init
-{
-  if (self = [super init]) {
-    _tasksMap = [NSMutableDictionary dictionary];
-  }
-  return self;
-}
-
-# pragma mark - Exported methods
-
-EX_EXPORT_METHOD_AS(handleNotificationAsync,
-                    handleNotificationAsync:(NSString *)identifier withBehavior:(NSDictionary *)behavior resolver:(EXPromiseResolveBlock)resolve rejecter:(EXPromiseRejectBlock)reject)
-{
-  EXSingleNotificationHandlerTask *task = _tasksMap[identifier];
-  if (!task) {
-    NSString *message = [NSString stringWithFormat:@"Failed to handle notification %@, it has already been handled.", identifier];
-    return reject(@"ERR_NOTIFICATION_HANDLED", message, nil);
-  }
-  NSError *error = [task handleResponse:behavior];
-  if (error) {
-    return reject(error.userInfo[@"code"], error.userInfo[@"message"], error);
-  } else {
-    resolve(nil);
-  }
-}
-
-# pragma mark - EXModuleRegistryConsumer
-
-- (void)setModuleRegistry:(EXModuleRegistry *)moduleRegistry
-{
-  _eventEmitter = [moduleRegistry getModuleImplementingProtocol:@protocol(EXEventEmitterService)];
-  _notificationCenterDelegate = [moduleRegistry getSingletonModuleForName:@"NotificationCenterDelegate"];
-}
-
-# pragma mark - EXEventEmitter
-
-- (NSArray<NSString *> *)supportedEvents
-{
-  return [EXSingleNotificationHandlerTask eventNames];
-}
-
-- (void)startObserving
-{
-  [self setIsBeingObserved:YES];
-}
-
-- (void)stopObserving
-{
-  [self setIsBeingObserved:NO];
-}
-
-- (void)setIsBeingObserved:(BOOL)isBeingObserved
-{
-  _isBeingObserved = isBeingObserved;
-  BOOL shouldListen = _isBeingObserved;
-  if (shouldListen && !_isListening) {
-    [_notificationCenterDelegate addDelegate:self];
-    _isListening = YES;
-  } else if (!shouldListen && _isListening) {
-    [_notificationCenterDelegate removeDelegate:self];
-    _isListening = NO;
-  }
-}
-
-# pragma mark - EXNotificationsDelegate
-
-- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler
-{
-  EXSingleNotificationHandlerTask *task = [[EXSingleNotificationHandlerTask alloc] initWithEventEmitter:_eventEmitter
-                                                                                           notification:notification
-                                                                                      completionHandler:completionHandler
-                                                                                               delegate:self];
-  [_tasksMap setObject:task forKey:task.identifier];
-  [task start];
-}
-
-# pragma mark - EXSingleNotificationHandlerTaskDelegate
-
-- (void)taskDidFinish:(EXSingleNotificationHandlerTask *)task
-{
-  [_tasksMap removeObjectForKey:task.identifier];
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXSingleNotificationHandlerTask.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXSingleNotificationHandlerTask.h
deleted file mode 100644
index b001ee6..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXSingleNotificationHandlerTask.h
+++ /dev/null
@@ -1,33 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <Foundation/Foundation.h>
-#import <ExpoModulesCore/EXEventEmitterService.h>
-#import <UserNotifications/UserNotifications.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@class EXSingleNotificationHandlerTask;
-
-@protocol EXSingleNotificationHandlerTaskDelegate
-
-- (void)taskDidFinish:(EXSingleNotificationHandlerTask *)task;
-
-@end
-
-@interface EXSingleNotificationHandlerTask : NSObject
-
-+ (NSArray<NSString *> *)eventNames;
-
-- (instancetype)initWithEventEmitter:(id<EXEventEmitterService>)eventEmitter
-                        notification:(UNNotification *)notification
-                   completionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler
-                            delegate:(id<EXSingleNotificationHandlerTaskDelegate>)delegate;
-
-- (NSString *)identifier;
-
-- (void)start;
-- (nullable NSError *)handleResponse:(NSDictionary *)response;
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXSingleNotificationHandlerTask.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXSingleNotificationHandlerTask.m
deleted file mode 100644
index 25fcd67..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/EXSingleNotificationHandlerTask.m
+++ /dev/null
@@ -1,124 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXSingleNotificationHandlerTask.h>
-#import <EXNotifications/EXNotificationSerializer.h>
-
-static NSString * const onHandleNotification = @"onHandleNotification";
-static NSString * const onHandleNotificationTimeout = @"onHandleNotificationTimeout";
-
-static NSString * const shouldShowAlertKey = @"shouldShowAlert";
-static NSString * const shouldPlaySoundKey = @"shouldPlaySound";
-static NSString * const shouldSetBadgeKey = @"shouldSetBadge";
-
-static NSTimeInterval const secondsToTimeout = 3;
-
-static NSString * const EXNotificationHandlerErrorDomain = @"expo.notifications.handler";
-
-@interface EXSingleNotificationHandlerTask ()
-
-@property (nonatomic, weak) id<EXEventEmitterService> eventEmitter;
-@property (nonatomic, strong) UNNotification *notification;
-@property (nonatomic, copy) void (^completionHandler)(UNNotificationPresentationOptions);
-
-@property (nonatomic, weak) id<EXSingleNotificationHandlerTaskDelegate> delegate;
-
-@property (nonatomic, strong) NSTimer *timer;
-
-@end
-
-@implementation EXSingleNotificationHandlerTask
-
-+ (NSArray<NSString *> *)eventNames
-{
-  return @[onHandleNotification, onHandleNotificationTimeout];
-}
-
-- (instancetype)initWithEventEmitter:(id<EXEventEmitterService>)eventEmitter
-                        notification:(UNNotification *)notification
-                   completionHandler:(void (^)(UNNotificationPresentationOptions))completionHandler
-                            delegate:(nonnull id<EXSingleNotificationHandlerTaskDelegate>)delegate
-{
-  if (self = [super init]) {
-    _eventEmitter = eventEmitter;
-    _notification = notification;
-    _completionHandler = completionHandler;
-    _delegate = delegate;
-  }
-  return self;
-}
-
-- (NSString *)identifier
-{
-  return _notification.request.identifier;
-}
-
-- (void)start
-{
-  [_eventEmitter sendEventWithName:onHandleNotification body:@{
-    @"id": _notification.request.identifier,
-    @"notification": [EXNotificationSerializer serializedNotification:_notification]
-  }];
-  _timer = [NSTimer scheduledTimerWithTimeInterval:secondsToTimeout target:self selector:@selector(handleTimeout) userInfo:nil repeats:NO];
-}
-
-- (nullable NSError *)handleResponse:(NSDictionary *)response
-{
-  @synchronized (self) {
-    NSError *maybeError = [self callCompletionHandlerWithOptions:[self presentationOptionsFromResponse:response]];
-    [self finish];
-    return maybeError;
-  }
-}
-
-- (void)handleTimeout
-{
-  @synchronized (self) {
-    [_eventEmitter sendEventWithName:onHandleNotificationTimeout body:@{
-      @"id": _notification.request.identifier,
-      @"notification": [EXNotificationSerializer serializedNotification:_notification]
-    }];
-    [self callCompletionHandlerWithOptions:UNNotificationPresentationOptionNone];
-    [self finish];
-  }
-}
-
-- (nullable NSError *)callCompletionHandlerWithOptions:(UNNotificationPresentationOptions)options
-{
-  if (_completionHandler) {
-    _completionHandler(options);
-    _completionHandler = nil;
-    return nil;
-  } else {
-    return [NSError errorWithDomain:EXNotificationHandlerErrorDomain code:-1 userInfo:@{
-      @"code": @"ERR_NOTIFICATION_RESPONSE_TIMEOUT",
-      @"message": @"Notification has already been handled. Most probably the request has timed out."
-    }];
-  }
-}
-
-- (void)finish
-{
-  [_timer invalidate];
-  _timer = nil;
-  [_delegate taskDidFinish:self];
-}
-
-- (UNNotificationPresentationOptions)presentationOptionsFromResponse:(NSDictionary *)response
-{
-  UNNotificationPresentationOptions options = UNNotificationPresentationOptionNone;
-
-  // TODO(iOS 14): use UNNotificationPresentationOptionList and UNNotificationPresentationOptionBanner
-  if ([response[shouldShowAlertKey] boolValue]) {
-    options |= UNNotificationPresentationOptionAlert;
-  }
-  if ([response[shouldPlaySoundKey] boolValue]) {
-    options |= UNNotificationPresentationOptionSound;
-  }
-  if ([response[shouldSetBadgeKey] boolValue]) {
-    options |= UNNotificationPresentationOptionBadge;
-  }
-
-  return options;
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/HandlerModule.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/HandlerModule.swift
new file mode 100644
index 0000000..440eabb
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/HandlerModule.swift
@@ -0,0 +1,67 @@
+//  Copyright © 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+let onHandleNotification = "onHandleNotification"
+let onHandleNotificationTimeout = "onHandleNotificationTimeout"
+
+public class HandlerModule: Module, NotificationDelegate, SingleNotificationHandlerTaskDelegate {
+  var tasksMap: [String: SingleNotificationHandlerTask] = [:]
+
+  public func definition() -> ModuleDefinition {
+    Name("ExpoNotificationsHandlerModule")
+
+    Events([onHandleNotification, onHandleNotificationTimeout])
+
+    OnStartObserving {
+      NotificationCenterManager.shared.addDelegate(self)
+    }
+
+    OnStopObserving {
+      NotificationCenterManager.shared.removeDelegate(self)
+    }
+
+    AsyncFunction("handleNotificationAsync") { (identifier: String, behavior: [String: Bool], promise: Promise) in
+      guard let task = tasksMap[identifier] else {
+        promise.reject("ERR_NOTIFICATION_HANDLED", "Failed to handle notification \(identifier) because it has already been handled")
+        return
+      }
+      if task.handleResponse(behavior) {
+        promise.resolve(nil)
+      } else {
+        promise.reject("ERR_NOTIFICATION_RESPONSE_TIMEOUT", "Notification has already been handled. Most probably the request has timed out.")
+      }
+    }
+  }
+
+  // MARK: - NotificationDelegate
+
+  public func willPresent(_ notification: UNNotification, completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) -> Bool {
+    let task = SingleNotificationHandlerTask(notification: notification, completionHandler: completionHandler, delegate: self)
+    tasksMap[task.identifier] = task
+    task.start()
+    return true
+  }
+
+  // MARK: - SingleNotificationHandlerTaskDelegate
+
+  public func taskDidFinish(_ task: SingleNotificationHandlerTask) {
+    tasksMap[task.identifier] = nil
+  }
+
+  public func handleNotification(_ notification: UNNotification) {
+    sendEvent(onHandleNotification, [
+      "id": notification.request.identifier,
+      "notification": EXNotificationSerializer.serializedNotification(notification)
+    ])
+  }
+
+  public func handleNotificationTimeout(_ notification: UNNotification) {
+    sendEvent(onHandleNotificationTimeout, [
+      "id": notification.request.identifier,
+      "notification": EXNotificationSerializer.serializedNotification(notification)
+    ])
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/SingleNotificationHandlerTask.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/SingleNotificationHandlerTask.swift
new file mode 100644
index 0000000..ae48e10
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Handler/SingleNotificationHandlerTask.swift
@@ -0,0 +1,84 @@
+//  Copyright © 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+
+let shouldShowAlertKey = "shouldShowAlert"
+let shouldPlaySoundKey = "shouldPlaySound"
+let shouldSetBadgeKey = "shouldSetBadge"
+
+public protocol SingleNotificationHandlerTaskDelegate: AnyObject {
+  func taskDidFinish(_ task: SingleNotificationHandlerTask)
+  func handleNotification(_ notification: UNNotification)
+  func handleNotificationTimeout(_ notification: UNNotification)
+}
+
+public class SingleNotificationHandlerTask {
+  public let identifier: String
+
+  private let notification: UNNotification
+  private var completionHandler: ((UNNotificationPresentationOptions) -> Void)?
+  private let delegate: SingleNotificationHandlerTaskDelegate
+
+  private var timer: Timer?
+
+  public init(
+    notification: UNNotification,
+    completionHandler: @escaping (UNNotificationPresentationOptions) -> Void,
+    delegate: SingleNotificationHandlerTaskDelegate
+  ) {
+    self.identifier = notification.request.identifier
+    self.delegate = delegate
+    self.notification = notification
+    self.completionHandler = completionHandler
+  }
+
+  public func start() {
+    delegate.handleNotification(notification)
+    timer = Timer.scheduledTimer(timeInterval: 3, target: self, selector: #selector(timeout), userInfo: nil, repeats: false)
+  }
+
+  @objc
+  public func timeout() {
+    delegate.handleNotificationTimeout(notification)
+    finish()
+  }
+
+  public func handleResponse(_ behavior: [String: Bool]) -> Bool {
+    if let completionHandler = completionHandler {
+      let options = presentationOptions(behavior)
+      completionHandler(options)
+      finish()
+      return true
+    }
+    finish()
+    return false
+  }
+
+  public func finish() {
+    timer?.invalidate()
+    self.completionHandler = nil
+    delegate.taskDidFinish(self)
+  }
+
+  func presentationOptions(_ behavior: [String: Any]) -> UNNotificationPresentationOptions {
+    var options: UNNotificationPresentationOptions = []
+
+    // (Alert option was deprecated in iOS 14)
+    if let shouldShowAlert = behavior[shouldShowAlertKey] as? Bool, shouldShowAlert {
+      options.insert(.alert)
+    }
+
+    if let shouldPlaySound = behavior[shouldPlaySoundKey] as? Bool, shouldPlaySound {
+      options.insert(.sound)
+    }
+
+    if let shouldSetBadge = behavior[shouldSetBadgeKey] as? Bool, shouldSetBadge {
+      options.insert(.badge)
+    }
+
+    // TODO(iOS 14): use UNNotificationPresentationOptionList and UNNotificationPresentationOptionBanner
+
+    return options
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationCenterManager.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationCenterManager.swift
index e584c1e..0594653 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationCenterManager.swift
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationCenterManager.swift
@@ -2,6 +2,7 @@
 
 import ExpoModulesCore
 import Foundation
+import UserNotifications
 
 /**
  Protocol that NotificationCenterManager delegates may implement
@@ -9,6 +10,7 @@ import Foundation
 public protocol NotificationDelegate: AnyObject {
   func willPresent(_ notification: UNNotification, completionHandler: @escaping (UNNotificationPresentationOptions) -> Void) -> Bool
   func didReceive(_ response: UNNotificationResponse, completionHandler: @escaping () -> Void) -> Bool
+  func didReceive(_ userInfo: [AnyHashable: Any], completionHandler: @escaping (UIBackgroundFetchResult) -> Void) -> Bool
   func openSettings(_ notification: UNNotification?)
   func didRegister(_ deviceToken: String)
   func didFailRegistration(_ error: Error)
@@ -21,6 +23,9 @@ public extension NotificationDelegate {
   func didReceive(_ response: UNNotificationResponse, completionHandler: @escaping () -> Void) -> Bool {
     return false
   }
+  func didReceive(_ userInfo: [AnyHashable: Any], completionHandler: @escaping (UIBackgroundFetchResult) -> Void) -> Bool {
+    return false
+  }
   func openSettings(_ notification: UNNotification?) {}
   func didRegister(_ deviceToken: String) {}
   func didFailRegistration(_ error: Error) {}
@@ -30,44 +35,37 @@ public extension NotificationDelegate {
  Singleton that sets itself as the UserNotificationCenter delegate,
  and calls its own delegates in response to notification center calls.
  */
-@objc(EXNotificationCenterManager)
 public class NotificationCenterManager: NSObject,
   UNUserNotificationCenterDelegate,
   NotificationDelegate {
   @objc
   public static let shared = NotificationCenterManager()
 
+  var lastResponse: UNNotificationResponse?
   var delegates: [NotificationDelegate] = []
   var pendingResponses: [UNNotificationResponse] = []
   let userNotificationCenter: UNUserNotificationCenter = UNUserNotificationCenter.current()
 
-  // TODO: Once Swift conversion is complete, the old EXNotificationDelegate class will be removed, and
-  // we will need to add the initialization code below.
-  // For now, we allow EXNotificationDelegate to add itself as the user notification delegate, and call the
-  // shared instance of this class.
-  //
-  /*
   private override init() {
     super.init()
     if UNUserNotificationCenter.current().delegate != nil {
       NSLog(
-        "[expo-notifications] EXNotificationCenterDelegate encountered already present delegate of " +
-        "UNUserNotificationCenter. EXNotificationCenterDelegate will not overwrite the value not to break other " +
+        "[expo-notifications] NotificationCenterManager encountered already present delegate of " +
+        "UNUserNotificationCenter. NotificationCenterManager will not overwrite the value not to break other " +
         "features of your app.  In return, expo-notifications may not work properly.  To fix this problem either " +
-        "remove setting of the second delegate, or set the delegate to an instance of EXNotificationCenterDelegate " +
+        "remove setting of the second delegate, or set the delegate to an instance of NotificationCenterManager " +
         "manually afterwards."
       )
       return
     }
     UNUserNotificationCenter.current().delegate = self
   }
-   */
 
   public func addDelegate(_ delegate: NotificationDelegate) {
     delegates.append(delegate)
     var handled = false
     for pendingResponse in pendingResponses {
-      handled = delegate.didReceive(pendingResponse, completionHandler: {})
+      handled = delegate.didReceive(pendingResponse, completionHandler: {}) || handled
     }
     if handled {
       pendingResponses.removeAll()
@@ -103,13 +101,10 @@ public class NotificationCenterManager: NSObject,
   ) {
     var handled = false
     for delegate in delegates {
-      handled = handled || delegate.willPresent(notification, completionHandler: completionHandler)
+      handled = delegate.willPresent(notification, completionHandler: completionHandler) || handled
     }
     if !handled {
-      // TODO: For now, until all code is converted to Swift,
-      // ensure notification is presented even if handlers are not registered
-      // Later revisit this
-      completionHandler([.badge, .banner, .sound])
+      completionHandler([])
     }
   }
 
@@ -120,7 +115,7 @@ public class NotificationCenterManager: NSObject,
   ) {
     var handled = false
     for delegate in delegates {
-      handled = handled || delegate.didReceive(response, completionHandler: completionHandler)
+      handled = delegate.didReceive(response, completionHandler: completionHandler) || handled
     }
     if !handled {
       pendingResponses.append(response)
@@ -133,4 +128,15 @@ public class NotificationCenterManager: NSObject,
       delegate.openSettings(notification)
     }
   }
+
+  // MARK: - Called from NotificationsAppDelegateSubscriber
+  public func didReceiveNotification(_ userInfo: [AnyHashable: Any], completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {
+    var handled = false
+    for delegate in delegates {
+      handled = delegate.didReceive(userInfo, completionHandler: completionHandler) || handled
+    }
+    if !handled {
+      completionHandler(.noData)
+    }
+  }
 }
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationsAppDelegateSubscriber.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationsAppDelegateSubscriber.swift
index 13206ba..d79b3bf 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationsAppDelegateSubscriber.swift
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/NotificationsAppDelegateSubscriber.swift
@@ -4,13 +4,27 @@ import Foundation
 public class NotificationsAppDelegateSubscriber: ExpoAppDelegateSubscriber {
   let notificationCenterManager = NotificationCenterManager.shared
 
-  public func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
+  public func application(
+    _ application: UIApplication,
+    didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data
+  ) {
     notificationCenterManager.didRegister(dataToString(deviceToken))
   }
 
-  public func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: any Error) {
+  public func application(
+    _ application: UIApplication,
+    didFailToRegisterForRemoteNotificationsWithError error: any Error
+  ) {
     notificationCenterManager.didFailRegistration(error)
   }
+
+  public func application(
+    _ application: UIApplication,
+    didReceiveRemoteNotification userInfo: [AnyHashable: Any],
+    fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void
+  ) {
+    notificationCenterManager.didReceive(userInfo, completionHandler: completionHandler)
+  }
 }
 
 private func dataToString(_ data: Data) -> String {
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/PresentationModule.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/PresentationModule.swift
index 245d9ae..436e2ed 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/PresentationModule.swift
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/PresentationModule.swift
@@ -76,6 +76,7 @@ public class PresentationModule: Module, NotificationDelegate {
 
   func serializeNotifications(_ notifications: [UNNotification]) -> [[AnyHashable: Any]] {
     return notifications.map { notification in
+      // TODO: convert serialization to Records
       return EXNotificationSerializer.serializedNotification(notification)
     }
   }
