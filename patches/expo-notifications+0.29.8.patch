diff --git a/node_modules/expo-notifications/expo-module.config.json b/node_modules/expo-notifications/expo-module.config.json
index 2c76073..ea22fd1 100644
--- a/node_modules/expo-notifications/expo-module.config.json
+++ b/node_modules/expo-notifications/expo-module.config.json
@@ -1,6 +1,10 @@
 {
   "name": "expo-notifications",
   "platforms": ["ios", "android"],
+  "ios": {
+    "modules": ["BadgeModule", "ServerRegistrationModule", "PushTokenModule", "SchedulerModule"],
+    "appDelegateSubscribers": ["PushTokenAppDelegateSubscriber"]
+  },
   "android": {
     "modules": [
       "expo.modules.notifications.badge.BadgeModule",
diff --git a/node_modules/expo-notifications/ios/EXNotifications.podspec b/node_modules/expo-notifications/ios/EXNotifications.podspec
index 9eb5769..6566237 100644
--- a/node_modules/expo-notifications/ios/EXNotifications.podspec
+++ b/node_modules/expo-notifications/ios/EXNotifications.podspec
@@ -18,12 +18,18 @@ Pod::Spec.new do |s|
 
   s.dependency 'ExpoModulesCore'
 
+  # Swift/Objective-C compatibility
+  s.pod_target_xcconfig = {
+    'DEFINES_MODULE' => 'YES',
+    'SWIFT_COMPILATION_MODE' => 'wholemodule'
+  }
+
   s.resource_bundles = {'ExpoNotifications_privacy' => ['PrivacyInfo.xcprivacy']}
 
   if !$ExpoUseSources&.include?(package['name']) && ENV['EXPO_USE_SOURCE'].to_i == 0 && File.exist?("#{s.name}.xcframework") && Gem::Version.new(Pod::VERSION) >= Gem::Version.new('1.10.0')
     s.source_files = "#{s.name}/**/*.h"
     s.vendored_frameworks = "#{s.name}.xcframework"
   else
-    s.source_files = "#{s.name}/**/*.{h,m}"
+    s.source_files = "#{s.name}/**/*.{h,m,swift}"
   end
 end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Badge/BadgeModule.swift b/node_modules/expo-notifications/ios/EXNotifications/Badge/BadgeModule.swift
new file mode 100644
index 0000000..62a5734
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Badge/BadgeModule.swift
@@ -0,0 +1,28 @@
+//  Copyright © 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+public class BadgeModule: Module {
+  public func definition() -> ModuleDefinition {
+    Name("ExpoBadgeModule")
+
+    AsyncFunction("getBadgeCountAsync") { () -> Int in
+      return EXSharedApplication().applicationIconBadgeNumber
+    }
+    .runOnQueue(.main)
+
+    AsyncFunction("setBadgeCountAsync") { (badgeCount: Int) -> Bool in
+      let settings = await UNUserNotificationCenter.current().notificationSettings()
+
+      if settings.badgeSetting == .enabled {
+        Task { @MainActor in
+          EXSharedApplication().applicationIconBadgeNumber = badgeCount
+        }
+        return true
+      }
+      return false
+    }
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Building/EXNotificationBuilder.h b/node_modules/expo-notifications/ios/EXNotifications/Building/EXNotificationBuilder.h
deleted file mode 100644
index 1089770..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Building/EXNotificationBuilder.h
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXInternalModule.h>
-
-#import <UserNotifications/UserNotifications.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@protocol EXNotificationBuilder
-
-- (UNMutableNotificationContent *)notificationContentFromRequest:(NSDictionary *)request;
-
-@end
-
-@interface EXNotificationBuilder : NSObject <EXInternalModule, EXNotificationBuilder>
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Building/EXNotificationBuilder.m b/node_modules/expo-notifications/ios/EXNotifications/Building/EXNotificationBuilder.m
deleted file mode 100644
index 53ec405..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Building/EXNotificationBuilder.m
+++ /dev/null
@@ -1,105 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXDefines.h>
-#import <EXNotifications/EXNotificationBuilder.h>
-#import <EXNotifications/NSDictionary+EXNotificationsVerifyingClass.h>
-
-@implementation EXNotificationBuilder
-
-EX_REGISTER_MODULE();
-
-+ (const NSArray<Protocol *> *)exportedInterfaces
-{
-  return @[@protocol(EXNotificationBuilder)];
-}
-
-- (UNMutableNotificationContent *)notificationContentFromRequest:(NSDictionary *)request
-{
-  UNMutableNotificationContent *content = [UNMutableNotificationContent new];
-  [content setTitle:[request objectForKey:@"title" verifyingClass:[NSString class]]];
-  [content setSubtitle:[request objectForKey:@"subtitle" verifyingClass:[NSString class]]];
-  [content setBody:[request objectForKey:@"body" verifyingClass:[NSString class]]];
-  [content setLaunchImageName:[request objectForKey:@"launchImageName" verifyingClass:[NSString class]]];
-  [content setBadge:[request objectForKey:@"badge" verifyingClass:[NSNumber class]]];
-  [content setUserInfo:[request objectForKey:@"data" verifyingClass:[NSDictionary class]]];
-  [content setCategoryIdentifier:[request objectForKey:@"categoryIdentifier" verifyingClass:[NSString class]]];
-  if ([request[@"sound"] isKindOfClass:[NSNumber class]]) {
-    [content setSound:[request[@"sound"] boolValue] ? [UNNotificationSound defaultSound] : nil];
-  } else if ([request[@"sound"] isKindOfClass:[NSString class]]) {
-    NSString *soundName = request[@"sound"];
-    if ([@"default" isEqualToString:soundName]) {
-      [content setSound:[UNNotificationSound defaultSound]];
-    } else if ([@"defaultCritical" isEqualToString:soundName]) {
-      [content setSound:[UNNotificationSound defaultCriticalSound]];
-    } else {
-      [content setSound:[UNNotificationSound soundNamed:soundName]];
-    }
-  }
-  NSMutableArray<UNNotificationAttachment *> *attachments = [NSMutableArray new];
-  [[request objectForKey:@"attachments" verifyingClass:[NSArray class]] enumerateObjectsUsingBlock:^(NSDictionary * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
-    UNNotificationAttachment *attachment = [self attachmentFromRequest:obj];
-    if (attachment) {
-      [attachments addObject:attachment];
-    }
-  }];
-  [content setAttachments:attachments];
-  NSString *interruptionLevel = [request objectForKey:@"interruptionLevel" verifyingClass:[NSString class]];
-  if (interruptionLevel) {
-    content.interruptionLevel = [EXNotificationBuilder deserializeInterruptionLevel:interruptionLevel];
-  }
-  return content;
-}
-
-+ (UNNotificationInterruptionLevel)deserializeInterruptionLevel:(NSString *)interruptionLevel API_AVAILABLE(ios(15.0)) {
-  static NSDictionary *interruptionLevelMap;
-  if (!interruptionLevelMap) {
-    interruptionLevelMap = @{
-      @"passive": @(UNNotificationInterruptionLevelPassive),
-      @"active": @(UNNotificationInterruptionLevelActive),
-      @"timeSensitive": @(UNNotificationInterruptionLevelTimeSensitive),
-      @"critical": @(UNNotificationInterruptionLevelCritical)
-    };
-  }
-  
-  return [interruptionLevelMap[interruptionLevel] integerValue];
-}
-
-- (UNNotificationAttachment *)attachmentFromRequest:(NSDictionary *)request
-{
-  NSString *identifier = [request objectForKey:@"identifier" verifyingClass:[NSString class]] ?: @"";
-  NSURL *uri = [NSURL URLWithString:[request objectForKey:@"uri" verifyingClass:[NSString class]]];
-  NSError *error = nil;
-  UNNotificationAttachment *attachment = [UNNotificationAttachment attachmentWithIdentifier:identifier URL:uri options:[self attachmentOptionsFromRequest:request] error:&error];
-  if (error) {
-    EXLogWarn(@"[expo-notifications] Could not have created a notification attachment out of request: %@. Error: %@.", [request description], [error description]);
-    return nil;
-  }
-  return attachment;
-}
-
-- (NSDictionary *)attachmentOptionsFromRequest:(NSDictionary *)request
-{
-  NSMutableDictionary *options = [NSMutableDictionary new];
-  if ([request objectForKey:@"typeHint" verifyingClass:[NSString class]]) {
-    options[UNNotificationAttachmentOptionsTypeHintKey] = request[@"typeHint"];
-  }
-  if ([request objectForKey:@"hideThumbnail" verifyingClass:[NSNumber class]]) {
-    options[UNNotificationAttachmentOptionsThumbnailHiddenKey] = request[@"hideThumbnail"];
-  }
-  if ([request objectForKey:@"thumbnailClipArea" verifyingClass:[NSDictionary class]]) {
-    NSDictionary *area = request[@"thumbnailClipArea"];
-    NSNumber *x = [area objectForKey:@"x" verifyingClass:[NSNumber class]];
-    NSNumber *y = [area objectForKey:@"y" verifyingClass:[NSNumber class]];
-    NSNumber *width = [area objectForKey:@"width" verifyingClass:[NSNumber class]];
-    NSNumber *height = [area objectForKey:@"height" verifyingClass:[NSNumber class]];
-    CGRect areaRect = CGRectMake([x doubleValue], [y doubleValue], [width doubleValue], [height doubleValue]);
-    options[UNNotificationAttachmentOptionsThumbnailClippingRectKey] = (__bridge id _Nullable)(CGRectCreateDictionaryRepresentation(areaRect));
-  }
-  if ([request objectForKey:@"thumbnailTime" verifyingClass:[NSNumber class]]) {
-    options[UNNotificationAttachmentOptionsThumbnailTimeKey] = request[@"thumbnailTime"];
-  }
-  return options;
-}
-
-@end
-
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Building/NotificationBuilder.swift b/node_modules/expo-notifications/ios/EXNotifications/Building/NotificationBuilder.swift
new file mode 100644
index 0000000..74c941a
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Building/NotificationBuilder.swift
@@ -0,0 +1,122 @@
+//  Copyright © 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+
+@objc(EXNotificationBuilder)
+public class NotificationBuilder: NSObject {
+  @objc(notificationContentFromRequest:error:)
+  public func content(_ request: [AnyHashable: Any]) throws -> UNMutableNotificationContent {
+    let content = UNMutableNotificationContent()
+
+    if let title: String = try? request.verifiedProperty("title", type: String.self) {
+      content.title = title
+    }
+
+    if let subtitle: String = try? request.verifiedProperty("subtitle", type: String.self) {
+      content.subtitle = subtitle
+    }
+
+    if let body: String = try? request.verifiedProperty("body", type: String.self) {
+      content.body = body
+    }
+
+    if let launchImageName: String = try? request.verifiedProperty("launchImageName", type: String.self) {
+      content.launchImageName = launchImageName
+    }
+
+    if let badge = try? request.verifiedProperty("badge", type: Int.self) {
+      // swiftlint:disable:next legacy_objc_type
+      content.badge = NSNumber.init(value: badge)
+    }
+
+    if let userInfo: [AnyHashable: Any] = try? request.verifiedProperty("userInfo", type: [AnyHashable: Any].self) {
+      content.userInfo = userInfo
+    }
+
+    if let categoryIdentifier: String = try? request.verifiedProperty("categoryIdentifier", type: String.self) {
+      content.categoryIdentifier = categoryIdentifier
+    }
+
+    if let sound = request["sound"] as? Bool {
+      content.sound = sound ? .default : .none
+    } else if let soundName = request["sound"] as? String {
+      if soundName == "default" {
+        content.sound = UNNotificationSound.default
+      } else if soundName == "defaultCritical" {
+        content.sound = UNNotificationSound.defaultCritical
+      } else {
+        content.sound = UNNotificationSound(named: UNNotificationSoundName(rawValue: soundName))
+      }
+    }
+    var attachments: [UNNotificationAttachment] = []
+    if let attachmentsArray = request["attachments"] as? [[String: Any]] {
+      for attachmentObject in attachmentsArray {
+        if let attachment: UNNotificationAttachment = attachment(attachmentObject) {
+          attachments.append(attachment)
+        }
+      }
+    }
+    content.attachments = attachments
+    if let interruptionLevel = request["interruptionLevel"] as? String {
+      content.interruptionLevel = deserializeInterruptionLevel(interruptionLevel)
+    }
+
+    return content
+  }
+
+  func attachment(_ request: [AnyHashable: Any]) -> UNNotificationAttachment? {
+    let identifier = request["identifier"] as? String ?? ""
+    let uri = request["uri"] as? String ?? ""
+    do {
+      if let url = URL(string: uri),
+        let attachment: UNNotificationAttachment =
+          try? UNNotificationAttachment(
+            identifier: identifier,
+            url: url,
+            options: attachmentOptions(request)
+          ) {
+        return attachment
+      }
+      return nil
+    }
+  }
+
+  func attachmentOptions(_ request: [AnyHashable: Any]) -> [AnyHashable: Any] {
+    var options: [AnyHashable: Any] = [:]
+    if let typeHint = request["typeHint"] as? String {
+      options[UNNotificationAttachmentOptionsTypeHintKey] = typeHint
+    }
+    if let hideThumbnail = request["hideThumbnail"] as? Bool {
+      options[UNNotificationAttachmentOptionsThumbnailHiddenKey] = hideThumbnail
+    }
+    if let thumbnailClipArea = request["thumbnailClipArea"] as? [String: Any] {
+      let x = thumbnailClipArea["x"] as? Double
+      let y = thumbnailClipArea["y"] as? Double
+      let width = thumbnailClipArea["width"] as? Double
+      let height = thumbnailClipArea["height"] as? Double
+      if let x, let y, let width, let height {
+        options[UNNotificationAttachmentOptionsThumbnailClippingRectKey] =
+          CGRect(
+            x: x,
+            y: y,
+            width: width,
+            height: height
+          )
+      }
+    }
+    if let thumbnailTime = request["thumbnailTime"] as? TimeInterval {
+      options[UNNotificationAttachmentOptionsThumbnailTimeKey] = thumbnailTime
+    }
+    return options
+  }
+
+  func deserializeInterruptionLevel(_ interruptionLevel: String) -> UNNotificationInterruptionLevel {
+    switch interruptionLevel {
+    case "passive": return .passive
+    case "active": return .active
+    case "timeSensitive": return .timeSensitive
+    case "critical": return .critical
+    default: return .passive
+    }
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/EXBadgeModule.h b/node_modules/expo-notifications/ios/EXNotifications/EXBadgeModule.h
deleted file mode 100644
index 76b2913..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/EXBadgeModule.h
+++ /dev/null
@@ -1,11 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@interface EXBadgeModule : EXExportedModule
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/EXBadgeModule.m b/node_modules/expo-notifications/ios/EXNotifications/EXBadgeModule.m
deleted file mode 100644
index 50b6784..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/EXBadgeModule.m
+++ /dev/null
@@ -1,36 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXBadgeModule.h>
-#import <ExpoModulesCore/EXUtilities.h>
-#import <UserNotifications/UserNotifications.h>
-
-@implementation EXBadgeModule
-
-EX_EXPORT_MODULE(ExpoBadgeModule)
-
-EX_EXPORT_METHOD_AS(getBadgeCountAsync,
-                    getBadgeCountAsync:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject)
-{
-  dispatch_async(dispatch_get_main_queue(), ^{
-    resolve(@([EXSharedApplication() applicationIconBadgeNumber]));
-  });
-}
-
-EX_EXPORT_METHOD_AS(setBadgeCountAsync,
-                    setBadgeCountAsync:(NSNumber *)badgeCount
-                    resolve:(EXPromiseResolveBlock)resolve
-                    reject:(EXPromiseRejectBlock)reject)
-{
-  [[UNUserNotificationCenter currentNotificationCenter] getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {
-    dispatch_async(dispatch_get_main_queue(), ^{
-      if (settings.badgeSetting == UNNotificationSettingEnabled) {
-        [EXSharedApplication() setApplicationIconBadgeNumber:badgeCount.integerValue];
-        resolve(@(YES));
-      } else {
-        resolve(@(NO));
-      }
-    });
-  }];
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/EXServerRegistrationModule.h b/node_modules/expo-notifications/ios/EXNotifications/EXServerRegistrationModule.h
deleted file mode 100644
index 22f2004..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/EXServerRegistrationModule.h
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@interface EXServerRegistrationModule : EXExportedModule
-
-- (NSString *)getInstallationId;
-
-- (void)getRegistrationInfoAsyncWithResolver:(EXPromiseResolveBlock)resolve
-                                    rejecter:(EXPromiseRejectBlock)reject;
-- (void)setRegistrationInfoAsync:(NSString *)registrationInfo
-                        resolver:(EXPromiseResolveBlock)resolve
-                        rejecter:(EXPromiseRejectBlock)reject;
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/EXServerRegistrationModule.m b/node_modules/expo-notifications/ios/EXNotifications/EXServerRegistrationModule.m
deleted file mode 100644
index 83e10fc..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/EXServerRegistrationModule.m
+++ /dev/null
@@ -1,195 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXServerRegistrationModule.h>
-
-// noop (used by code transform to ensure the versioning isn't applied)
-#define EX_UNVERSIONED(symbol) symbol
-
-static NSString * const kEXDeviceInstallationUUIDKey = EX_UNVERSIONED(@"EXDeviceInstallationUUIDKey");
-static NSString * const kEXDeviceInstallationUUIDLegacyKey = EX_UNVERSIONED(@"EXDeviceInstallUUIDKey");
-
-static NSString * const kEXRegistrationInfoKey = EX_UNVERSIONED(@"EXNotificationRegistrationInfoKey");
-
-@implementation EXServerRegistrationModule
-
-EX_EXPORT_MODULE(NotificationsServerRegistrationModule)
-
-EX_EXPORT_METHOD_AS(getInstallationIdAsync,
-                    getInstallationIdAsyncWithResolver:(EXPromiseResolveBlock)resolve
-                                              rejecter:(EXPromiseRejectBlock)reject)
-{
-  resolve([self getInstallationId]);
-}
-
-- (NSString *)getInstallationId
-{
-  NSString *installationId = [self fetchInstallationId];
-  if (installationId) {
-    return installationId;
-  }
-  
-  installationId = [[NSUUID UUID] UUIDString];
-  [self setInstallationId:installationId error:NULL];
-  return installationId;
-}
-
-- (nullable NSString *)fetchInstallationId
-{
-  NSString *installationId;
-  CFTypeRef keychainResult = NULL;
-  
-  if (SecItemCopyMatching((__bridge CFDictionaryRef)[self installationIdGetQuery], &keychainResult) == noErr) {
-    NSData *result = (__bridge_transfer NSData *)keychainResult;
-    NSString *value = [[NSString alloc] initWithData:result
-                                            encoding:NSUTF8StringEncoding];
-    // `initWithUUIDString` returns nil if string is not a valid UUID
-    if ([[NSUUID alloc] initWithUUIDString:value]) {
-      installationId = value;
-    }
-  }
-  
-  if (installationId) {
-    return installationId;
-  }
-  
-  // Uses required reason API based on the following reason: CA92.1
-  NSString *legacyUUID = [[NSUserDefaults standardUserDefaults] stringForKey:kEXDeviceInstallationUUIDLegacyKey];
-  if (legacyUUID) {
-    installationId = legacyUUID;
-
-    NSError *error = nil;
-    if ([self setInstallationId:installationId error:&error]) {
-      // We only remove the value from old storage once it's set and saved in the new storage.
-      [[NSUserDefaults standardUserDefaults] removeObjectForKey:kEXDeviceInstallationUUIDLegacyKey];
-    } else {
-      NSLog(@"Could not migrate device installation UUID from legacy storage: %@", error.description);
-    }
-  }
-  
-  return installationId;
-}
-
-- (BOOL)setInstallationId:(NSString *)installationId error:(NSError **)error
-{
-  // Delete existing UUID so we don't need to handle "duplicate item" error
-  SecItemDelete((__bridge CFDictionaryRef)[self installationIdSearchQuery]);
-  
-  OSStatus status = SecItemAdd((__bridge CFDictionaryRef)[self installationIdSetQuery:installationId], NULL);
-  if (status != errSecSuccess && error) {
-    *error = [NSError errorWithDomain:NSOSStatusErrorDomain code:status userInfo:nil];
-  }
-  return status == errSecSuccess;
-}
-
-# pragma mark - Keychain dictionaries
-
-- (NSDictionary *)keychainSearchQueryFor:(NSString *)key merging:(NSDictionary *)dictionaryToMerge
-{
-  NSData *encodedKey = [key dataUsingEncoding:NSUTF8StringEncoding];
-  NSMutableDictionary *query = [NSMutableDictionary dictionaryWithDictionary:@{
-    (__bridge id)kSecClass:(__bridge id)kSecClassGenericPassword,
-    (__bridge id)kSecAttrService:[NSBundle mainBundle].bundleIdentifier,
-    (__bridge id)kSecAttrGeneric:encodedKey,
-    (__bridge id)kSecAttrAccount:encodedKey
-  }];
-  [query addEntriesFromDictionary:dictionaryToMerge];
-  return query;
-}
-
-# pragma mark Installation ID
-
-- (NSDictionary *)installationIdSearchQueryMerging:(NSDictionary *)dictionaryToMerge
-{
-  return [self keychainSearchQueryFor:kEXDeviceInstallationUUIDKey merging:dictionaryToMerge];
-}
-
-- (NSDictionary *)installationIdSearchQuery
-{
-  return [self installationIdSearchQueryMerging:@{}];
-}
-
-- (NSDictionary *)installationIdGetQuery
-{
-  return [self installationIdSearchQueryMerging:@{
-    (__bridge id)kSecMatchLimit:(__bridge id)kSecMatchLimitOne,
-    (__bridge id)kSecReturnData:(__bridge id)kCFBooleanTrue
-  }];
-}
-
-- (NSDictionary *)installationIdSetQuery:(NSString *)deviceInstallationUUID
-{
-  return [self installationIdSearchQueryMerging:@{
-    (__bridge id)kSecValueData:[deviceInstallationUUID dataUsingEncoding:NSUTF8StringEncoding],
-    (__bridge id)kSecAttrAccessible:(__bridge id)kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly
-  }];
-}
-
-# pragma mark Registration information
-
-- (NSDictionary *)registrationSearchQueryMerging:(NSDictionary *)dictionaryToMerge
-{
-  return [self keychainSearchQueryFor:kEXRegistrationInfoKey merging:dictionaryToMerge];
-}
-
-- (NSDictionary *)registrationSearchQuery
-{
-  return [self registrationSearchQueryMerging:@{}];
-}
-
-- (NSDictionary *)registrationGetQuery
-{
-  return [self registrationSearchQueryMerging:@{
-    (__bridge id)kSecMatchLimit:(__bridge id)kSecMatchLimitOne,
-    (__bridge id)kSecReturnData:(__bridge id)kCFBooleanTrue
-  }];
-}
-
-- (NSDictionary *)registrationSetQuery:(NSString *)registration
-{
-  return [self registrationSearchQueryMerging:@{
-    (__bridge id)kSecValueData:[registration dataUsingEncoding:NSUTF8StringEncoding],
-    (__bridge id)kSecAttrAccessible:(__bridge id)kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly
-  }];
-}
-
-EX_EXPORT_METHOD_AS(getRegistrationInfoAsync,
-                    getRegistrationInfoAsyncWithResolver:(EXPromiseResolveBlock)resolve
-                                                rejecter:(EXPromiseRejectBlock)reject)
-{
-  CFTypeRef keychainResult = NULL;
-  OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)[self registrationGetQuery], &keychainResult);
-  if (status == noErr) {
-    NSData *result = (__bridge_transfer NSData *)keychainResult;
-    NSString *value = [[NSString alloc] initWithData:result
-                                            encoding:NSUTF8StringEncoding];
-    resolve(value);
-  } else if (status == errSecItemNotFound) {
-    resolve(nil);
-  } else {
-    NSError *error = [NSError errorWithDomain:NSOSStatusErrorDomain code:status userInfo:nil];
-    reject(@"ERR_NOTIFICATIONS_KEYCHAIN_ACCESS", @"Could not fetch registration information from keychain.", error);
-  }
-}
-
-EX_EXPORT_METHOD_AS(setRegistrationInfoAsync,
-                    setRegistrationInfoAsync:(NSString *)registrationInfo
-                                    resolver:(EXPromiseResolveBlock)resolve
-                                    rejecter:(EXPromiseRejectBlock)reject)
-{
-  // Delete existing registration so we don't need to handle "duplicate item" error
-  SecItemDelete((__bridge CFDictionaryRef)[self registrationSearchQuery]);
-  
-  if (registrationInfo) {
-    OSStatus status = SecItemAdd((__bridge CFDictionaryRef)[self registrationSetQuery:registrationInfo], NULL);
-    if (status == errSecSuccess) {
-      resolve(nil);
-    } else {
-      NSError *error = [NSError errorWithDomain:NSOSStatusErrorDomain code:status userInfo:nil];
-      reject(@"ERR_NOTIFICATIONS_KEYCHAIN_ACCESS", @"Could not save registration information into keychain.", error);
-    }
-  } else {
-    resolve(nil);
-  }
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/EXNotificationPresentationModule.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/EXNotificationPresentationModule.m
index 8410fa4..9c67fad 100644
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/EXNotificationPresentationModule.m
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Presenting/EXNotificationPresentationModule.m
@@ -2,17 +2,21 @@
 
 #import <EXNotifications/EXNotificationPresentationModule.h>
 
-#import <EXNotifications/EXNotificationBuilder.h>
 #import <EXNotifications/EXNotificationSerializer.h>
 #import <EXNotifications/EXNotificationCenterDelegate.h>
 
-@interface EXNotificationPresentationModule ()
+#if __has_include(<EXNotifications/EXNotifications-Swift.h>)
+#import <EXNotifications/EXNotifications-Swift.h>
+#else
+#import "EXNotifications-Swift.h"
+#endif
 
-@property (nonatomic, weak) id<EXNotificationBuilder> notificationBuilder;
+@interface EXNotificationPresentationModule ()
 
 // Remove once presentNotificationAsync is removed
 @property (nonatomic, strong) NSCountedSet<NSString *> *presentedNotifications;
 @property (nonatomic, weak) id<EXNotificationCenterDelegate> notificationCenterDelegate;
+@property (nonatomic, strong) EXNotificationBuilder *builder;
 
 @end
 
@@ -25,6 +29,7 @@ EX_EXPORT_MODULE(ExpoNotificationPresenter);
 {
   if (self = [super init]) {
     _presentedNotifications = [NSCountedSet set];
+    self.builder = [EXNotificationBuilder new];
   }
   return self;
 }
@@ -38,7 +43,12 @@ EX_EXPORT_METHOD_AS(presentNotificationAsync,
                     resolve:(EXPromiseResolveBlock)resolve
                     reject:(EXPromiseRejectBlock)reject)
 {
-  UNNotificationContent *content = [_notificationBuilder notificationContentFromRequest:notificationSpec];
+  NSError *error = nil;
+  UNNotificationContent *content = [self.builder notificationContentFromRequest:notificationSpec error:&error];
+  if (error) {
+    NSString *message = [NSString stringWithFormat:@"Notification could not have been presented: %@", error.description];
+    reject(@"ERR_NOTIF_PRESENT", message, error);
+  }
   UNNotificationTrigger *trigger = nil;
   UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:identifier content:content trigger:trigger];
   [_presentedNotifications addObject:identifier];
@@ -86,8 +96,6 @@ EX_EXPORT_METHOD_AS(dismissAllNotificationsAsync,
 
 - (void)setModuleRegistry:(EXModuleRegistry *)moduleRegistry
 {
-  _notificationBuilder = [moduleRegistry getModuleImplementingProtocol:@protocol(EXNotificationBuilder)];
-
   // Remove once presentNotificationAsync is removed
   id<EXNotificationCenterDelegate> notificationCenterDelegate = (id<EXNotificationCenterDelegate>)[moduleRegistry getSingletonModuleForName:@"NotificationCenterDelegate"];
   [notificationCenterDelegate addDelegate:self];
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.h b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.h
deleted file mode 100644
index a7fff4c..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.h
+++ /dev/null
@@ -1,21 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-#import <ExpoModulesCore/EXModuleRegistryConsumer.h>
-#import <UserNotifications/UserNotifications.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@interface EXNotificationSchedulerModule : EXExportedModule <EXModuleRegistryConsumer>
-
-- (NSArray * _Nonnull)serializeNotificationRequests:(NSArray<UNNotificationRequest *> * _Nonnull) requests;
-
-- (void)cancelNotification:(NSString *)identifier resolve:(EXPromiseResolveBlock)resolve rejecting:(EXPromiseRejectBlock)reject;
-
-- (void)cancelAllNotificationsWithResolver:(EXPromiseResolveBlock)resolve rejecting:(EXPromiseRejectBlock)reject;
-
-- (UNNotificationRequest *)buildNotificationRequestWithIdentifier:(NSString *)identifier content:(NSDictionary *)contentInput trigger:(NSDictionary *)triggerInput;
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.m b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.m
deleted file mode 100644
index 49e7453..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/EXNotificationSchedulerModule.m
+++ /dev/null
@@ -1,279 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXNotificationSchedulerModule.h>
-#import <EXNotifications/EXNotificationSerializer.h>
-#import <EXNotifications/EXNotificationBuilder.h>
-#import <EXNotifications/NSDictionary+EXNotificationsVerifyingClass.h>
-
-#import <UserNotifications/UserNotifications.h>
-
-static NSString * const notificationTriggerTypeKey = @"type";
-static NSString * const notificationTriggerRepeatsKey = @"repeats";
-
-static NSString * const intervalNotificationTriggerType = @"timeInterval";
-static NSString * const intervalNotificationTriggerIntervalKey = @"seconds";
-
-static NSString * const dailyNotificationTriggerType = @"daily";
-static NSString * const dailyNotificationTriggerHourKey = @"hour";
-static NSString * const dailyNotificationTriggerMinuteKey = @"minute";
-
-static NSString * const weeklyNotificationTriggerType = @"weekly";
-static NSString * const weeklyNotificationTriggerWeekdayKey = @"weekday";
-static NSString * const weeklyNotificationTriggerHourKey = @"hour";
-static NSString * const weeklyNotificationTriggerMinuteKey = @"minute";
-
-static NSString * const monthlyNotificationTriggerType = @"monthly";
-static NSString * const monthlyNotificationTriggerDayKey = @"day";
-static NSString * const monthlyNotificationTriggerHourKey = @"hour";
-static NSString * const monthlyNotificationTriggerMinuteKey = @"minute";
-
-static NSString * const yearlyNotificationTriggerType = @"yearly";
-static NSString * const yearlyNotificationTriggerDayKey = @"day";
-static NSString * const yearlyNotificationTriggerMonthKey = @"month";
-static NSString * const yearlyNotificationTriggerHourKey = @"hour";
-static NSString * const yearlyNotificationTriggerMinuteKey = @"minute";
-
-static NSString * const dateNotificationTriggerType = @"date";
-static NSString * const dateNotificationTriggerTimestampKey = @"timestamp";
-
-static NSString * const calendarNotificationTriggerType = @"calendar";
-static NSString * const calendarNotificationTriggerComponentsKey = @"value";
-static NSString * const calendarNotificationTriggerTimezoneKey = @"timezone";
-
-
-
-@interface EXNotificationSchedulerModule ()
-
-@property (nonatomic, weak) id<EXNotificationBuilder> builder;
-
-@end
-
-@implementation EXNotificationSchedulerModule
-
-EX_EXPORT_MODULE(ExpoNotificationScheduler);
-
-- (void)setModuleRegistry:(EXModuleRegistry *)moduleRegistry
-{
-  _builder = [moduleRegistry getModuleImplementingProtocol:@protocol(EXNotificationBuilder)];
-}
-
-# pragma mark - Exported methods
-
-EX_EXPORT_METHOD_AS(getAllScheduledNotificationsAsync,
-                    getAllScheduledNotifications:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject
-                    )
-{
-  [[UNUserNotificationCenter currentNotificationCenter] getPendingNotificationRequestsWithCompletionHandler:^(NSArray<UNNotificationRequest *> * _Nonnull requests) {
-    resolve([self serializeNotificationRequests:requests]);
-  }];
-}
-
-EX_EXPORT_METHOD_AS(scheduleNotificationAsync,
-                     scheduleNotification:(NSString *)identifier notificationSpec:(NSDictionary *)notificationSpec triggerSpec:(NSDictionary *)triggerSpec resolve:(EXPromiseResolveBlock)resolve rejecting:(EXPromiseRejectBlock)reject)
-{
-  @try {
-    UNNotificationRequest *request = [self buildNotificationRequestWithIdentifier:identifier content:notificationSpec trigger:triggerSpec];
-    [[UNUserNotificationCenter currentNotificationCenter] addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {
-      if (error) {
-        NSString *message = [NSString stringWithFormat:@"Failed to schedule notification. %@", error];
-        reject(@"ERR_NOTIFICATIONS_FAILED_TO_SCHEDULE", message, error);
-      } else {
-        resolve(identifier);
-      }
-    }];
-  } @catch (NSException *exception) {
-    NSString *message = [NSString stringWithFormat:@"Failed to schedule notification. %@", exception];
-    reject(@"ERR_NOTIFICATIONS_FAILED_TO_SCHEDULE", message, nil);
-  }
-}
-
-EX_EXPORT_METHOD_AS(cancelScheduledNotificationAsync,
-                     cancelNotification:(NSString *)identifier resolve:(EXPromiseResolveBlock)resolve rejecting:(EXPromiseRejectBlock)reject)
-{
-  [[UNUserNotificationCenter currentNotificationCenter] removePendingNotificationRequestsWithIdentifiers:@[identifier]];
-  resolve(nil);
-}
-
-EX_EXPORT_METHOD_AS(cancelAllScheduledNotificationsAsync,
-                     cancelAllNotificationsWithResolver:(EXPromiseResolveBlock)resolve rejecting:(EXPromiseRejectBlock)reject)
-{
-  [[UNUserNotificationCenter currentNotificationCenter] removeAllPendingNotificationRequests];
-  resolve(nil);
-}
-
-EX_EXPORT_METHOD_AS(getNextTriggerDateAsync,
-                    getNextTriggerDate:(NSDictionary *)triggerSpec resolve:(EXPromiseResolveBlock)resolve rejecting:(EXPromiseRejectBlock)reject)
-{
-  @try {
-    UNNotificationTrigger *trigger = [self triggerFromParams:triggerSpec];
-    if ([trigger isKindOfClass:[UNCalendarNotificationTrigger class]]) {
-      UNCalendarNotificationTrigger *calendarTrigger = (UNCalendarNotificationTrigger *)trigger;
-      NSDate *nextTriggerDate = [calendarTrigger nextTriggerDate];
-      // We want to return milliseconds from this method.
-      resolve(nextTriggerDate ? @([nextTriggerDate timeIntervalSince1970] * 1000) : [NSNull null]);
-    } else if ([trigger isKindOfClass:[UNTimeIntervalNotificationTrigger class]]) {
-      UNTimeIntervalNotificationTrigger *timeIntervalTrigger = (UNTimeIntervalNotificationTrigger *)trigger;
-      NSDate *nextTriggerDate = [timeIntervalTrigger nextTriggerDate];
-      // We want to return milliseconds from this method.
-      resolve(nextTriggerDate ? @([nextTriggerDate timeIntervalSince1970] * 1000) : [NSNull null]);
-    } else {
-      NSString *message = [NSString stringWithFormat:@"It is not possible to get next trigger date for triggers other than calendar-based. Provided trigger resulted in %@ trigger.", NSStringFromClass([trigger class])];
-      reject(@"ERR_NOTIFICATIONS_INVALID_CALENDAR_TRIGGER", message, nil);
-    }
-  } @catch (NSException *exception) {
-    NSString *message = [NSString stringWithFormat:@"Failed to get next trigger date. %@", exception];
-    reject(@"ERR_NOTIFICATIONS_FAILED_TO_GET_NEXT_TRIGGER_DATE", message, nil);
-  }
-}
-
-- (UNNotificationRequest *)buildNotificationRequestWithIdentifier:(NSString *)identifier
-                                                          content:(NSDictionary *)contentInput
-                                                          trigger:(NSDictionary *)triggerInput
-{
-  UNNotificationContent *content = [_builder notificationContentFromRequest:contentInput];
-  UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:identifier content:content trigger:[self triggerFromParams:triggerInput]];
-  return request;
-}
-
-- (NSArray * _Nonnull)serializeNotificationRequests:(NSArray<UNNotificationRequest *> * _Nonnull) requests
-{
-  NSMutableArray *serializedRequests = [NSMutableArray new];
-  for (UNNotificationRequest *request in requests) {
-    [serializedRequests addObject:[EXNotificationSerializer serializedNotificationRequest:request]];
-  }
-  return serializedRequests;
-}
-
-- (UNNotificationTrigger *)triggerFromParams:(NSDictionary *)params
-{
-  if (!params) {
-    // nil trigger is a valid trigger
-    return nil;
-  }
-  if (![params isKindOfClass:[NSDictionary class]]) {
-    NSString *reason = [NSString stringWithFormat:@"Unknown notification trigger declaration passed in, expected a dictionary, received %@.", NSStringFromClass(params.class)];
-    @throw [NSException exceptionWithName:NSInvalidArgumentException reason:reason userInfo:nil];
-  }
-  NSString *triggerType = params[notificationTriggerTypeKey];
-  if ([intervalNotificationTriggerType isEqualToString:triggerType]) {
-    NSNumber *interval = [params objectForKey:intervalNotificationTriggerIntervalKey verifyingClass:[NSNumber class]];
-    NSNumber *repeats = [params objectForKey:notificationTriggerRepeatsKey verifyingClass:[NSNumber class]];
-
-    return [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:[interval unsignedIntegerValue]
-                                                              repeats:[repeats boolValue]];
-  } else if ([dateNotificationTriggerType isEqualToString:triggerType]) {
-    NSNumber *timestampMs = [params objectForKey:dateNotificationTriggerTimestampKey verifyingClass:[NSNumber class]];
-    NSUInteger timestamp = [timestampMs unsignedIntegerValue] / 1000;
-    NSDate *date = [NSDate dateWithTimeIntervalSince1970:timestamp];
-
-    return [UNTimeIntervalNotificationTrigger triggerWithTimeInterval:[date timeIntervalSinceNow]
-                                                              repeats:NO];
-
-  } else if ([dailyNotificationTriggerType isEqualToString:triggerType]) {
-    NSNumber *hour = [params objectForKey:dailyNotificationTriggerHourKey verifyingClass:[NSNumber class]];
-    NSNumber *minute = [params objectForKey:dailyNotificationTriggerMinuteKey verifyingClass:[NSNumber class]];
-    NSDateComponents *dateComponents = [NSDateComponents new];
-    dateComponents.hour = [hour integerValue];
-    dateComponents.minute = [minute integerValue];
-
-    return [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:dateComponents
-                                                                    repeats:YES];
-  } else if ([weeklyNotificationTriggerType isEqualToString:triggerType]) {
-    NSNumber *weekday = [params objectForKey:weeklyNotificationTriggerWeekdayKey verifyingClass:[NSNumber class]];
-    NSNumber *hour = [params objectForKey:weeklyNotificationTriggerHourKey verifyingClass:[NSNumber class]];
-    NSNumber *minute = [params objectForKey:weeklyNotificationTriggerMinuteKey verifyingClass:[NSNumber class]];
-    NSDateComponents *dateComponents = [NSDateComponents new];
-    dateComponents.weekday = [weekday integerValue];
-    dateComponents.hour = [hour integerValue];
-    dateComponents.minute = [minute integerValue];
-
-    return [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:dateComponents
-                                                                    repeats:YES];
-  } else if ([monthlyNotificationTriggerType isEqualToString:triggerType]) {
-    NSNumber *day = [params objectForKey:monthlyNotificationTriggerDayKey verifyingClass:[NSNumber class]];
-    NSNumber *hour = [params objectForKey:monthlyNotificationTriggerHourKey verifyingClass:[NSNumber class]];
-    NSNumber *minute = [params objectForKey:monthlyNotificationTriggerMinuteKey verifyingClass:[NSNumber class]];
-    NSDateComponents *dateComponents = [NSDateComponents new];
-    dateComponents.day = [day integerValue];
-    dateComponents.hour = [hour integerValue];
-    dateComponents.minute = [minute integerValue];
-
-    return [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:dateComponents
-                                                                    repeats:YES];
-  } else if ([yearlyNotificationTriggerType isEqualToString:triggerType]) {
-    NSNumber *day = [params objectForKey:yearlyNotificationTriggerDayKey verifyingClass:[NSNumber class]];
-    NSNumber *month = [params objectForKey:yearlyNotificationTriggerMonthKey verifyingClass:[NSNumber class]];
-    NSNumber *hour = [params objectForKey:yearlyNotificationTriggerHourKey verifyingClass:[NSNumber class]];
-    NSNumber *minute = [params objectForKey:yearlyNotificationTriggerMinuteKey verifyingClass:[NSNumber class]];
-    NSDateComponents *dateComponents = [NSDateComponents new];
-    dateComponents.day = [day integerValue];
-    dateComponents.month = [month integerValue] + 1; // iOS uses 1-12 based numbers for months
-    dateComponents.hour = [hour integerValue];
-    dateComponents.minute = [minute integerValue];
-
-    return [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:dateComponents
-                                                                    repeats:YES];
-  } else if ([calendarNotificationTriggerType isEqualToString:triggerType]) {
-    NSDateComponents *dateComponents = [self dateComponentsFromParams:params[calendarNotificationTriggerComponentsKey]];
-    NSNumber *repeats = [params objectForKey:notificationTriggerRepeatsKey verifyingClass:[NSNumber class]];
-
-    return [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:dateComponents
-                                                                    repeats:[repeats boolValue]];
-  } else {
-    NSString *reason = [NSString stringWithFormat:@"Unknown notification trigger type: %@.", triggerType];
-    @throw [NSException exceptionWithName:NSInvalidArgumentException reason:reason userInfo:nil];
-  }
-}
-
-- (NSDateComponents *)dateComponentsFromParams:(NSDictionary<NSString *, id> *)params
-{
-  NSDateComponents *dateComponents = [NSDateComponents new];
-
-  // TODO: Verify that DoW matches JS getDay()
-  dateComponents.calendar = [NSCalendar calendarWithIdentifier:NSCalendarIdentifierISO8601];
-
-  if ([params objectForKey:calendarNotificationTriggerTimezoneKey verifyingClass:[NSString class]]) {
-    dateComponents.timeZone = [[NSTimeZone alloc] initWithName:params[calendarNotificationTriggerTimezoneKey]];
-  }
-
-  for (NSString *key in [self automatchedDateComponentsKeys]) {
-    if (params[key]) {
-      NSNumber *value = [params objectForKey:key verifyingClass:[NSNumber class]];
-      [dateComponents setValue:[value unsignedIntegerValue] forComponent:[self calendarUnitFor:key]];
-    }
-  }
-
-  return dateComponents;
-}
-
-- (NSDictionary<NSString *, NSNumber *> *)dateComponentsMatchMap
-{
-  static NSDictionary *map;
-  if (!map) {
-    map = @{
-      @"year": @(NSCalendarUnitYear),
-      @"month": @(NSCalendarUnitMonth),
-      @"day": @(NSCalendarUnitDay),
-      @"hour": @(NSCalendarUnitHour),
-      @"minute": @(NSCalendarUnitMinute),
-      @"second": @(NSCalendarUnitSecond),
-      @"weekday": @(NSCalendarUnitWeekday),
-      @"weekOfMonth": @(NSCalendarUnitWeekOfMonth),
-      @"weekOfYear": @(NSCalendarUnitWeekOfYear),
-      @"weekdayOrdinal": @(NSCalendarUnitWeekdayOrdinal)
-    };
-  }
-  return map;
-}
-
-- (NSArray<NSString *> *)automatchedDateComponentsKeys
-{
-  return [[self dateComponentsMatchMap] allKeys];
-}
-
-- (NSCalendarUnit)calendarUnitFor:(NSString *)key
-{
-  return [[self dateComponentsMatchMap][key] unsignedIntegerValue];
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/SchedulerModule.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/SchedulerModule.swift
new file mode 100644
index 0000000..15b9e4f
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/Scheduling/SchedulerModule.swift
@@ -0,0 +1,212 @@
+//  Copyright © 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+// swiftlint:disable identifier_name
+let notificationTriggerTypeKey = "type"
+let notificationTriggerRepeatsKey = "repeats"
+
+let intervalNotificationTriggerType = "timeInterval"
+let intervalNotificationTriggerIntervalKey = "seconds"
+
+let dailyNotificationTriggerType = "daily"
+let dailyNotificationTriggerHourKey = "hour"
+let dailyNotificationTriggerMinuteKey = "minute"
+
+let weeklyNotificationTriggerType = "weekly"
+let weeklyNotificationTriggerWeekdayKey = "weekday"
+let weeklyNotificationTriggerHourKey = "hour"
+let weeklyNotificationTriggerMinuteKey = "minute"
+
+let monthlyNotificationTriggerType = "monthly"
+let monthlyNotificationTriggerDayKey = "day"
+let monthlyNotificationTriggerHourKey = "hour"
+let monthlyNotificationTriggerMinuteKey = "minute"
+
+let yearlyNotificationTriggerType = "yearly"
+let yearlyNotificationTriggerMonthKey = "month"
+let yearlyNotificationTriggerDayKey = "day"
+let yearlyNotificationTriggerHourKey = "hour"
+let yearlyNotificationTriggerMinuteKey = "minute"
+
+let dateNotificationTriggerType = "date"
+let dateNotificationTriggerTimestampKey = "timestamp"
+
+let calendarNotificationTriggerType = "calendar"
+let calendarNotificationTriggerComponentsKey = "value"
+let calendarNotificationTriggerTimezoneKey = "timezone"
+// swiftlint:enable identifier_name
+
+let dateComponentsMatchMap: [String: Calendar.Component] = [
+  "year": .year,
+  "month": .month,
+  "day": .day,
+  "hour": .hour,
+  "minute": .minute,
+  "second": .second,
+  "weekday": .weekday,
+  "weekOfMonth": .weekOfMonth,
+  "weekOfYear": .weekOfYear,
+  "weekdayOrdinal": .weekdayOrdinal
+]
+
+public class SchedulerModule: Module {
+  let builder: NotificationBuilder = NotificationBuilder()
+
+  func triggerFromParams(_ params: [AnyHashable: Any]?) throws -> UNNotificationTrigger? {
+    guard let params = params else {
+      return nil
+    }
+
+    guard let triggerType = params[notificationTriggerTypeKey] as? String else {
+      return nil
+    }
+
+    switch triggerType {
+    case intervalNotificationTriggerType:
+      let interval = (try? params.verifiedProperty(intervalNotificationTriggerIntervalKey, type: TimeInterval.self)) ?? 0
+      let repeats: Bool = ((try? params.verifiedProperty(notificationTriggerRepeatsKey, type: Bool.self) ?? false) != nil)
+      return UNTimeIntervalNotificationTrigger(timeInterval: interval, repeats: repeats)
+    case dateNotificationTriggerType:
+      let timestampMs: TimeInterval = (try? params.verifiedProperty(dateNotificationTriggerTimestampKey, type: TimeInterval.self)) ?? 0
+      let timestamp: Int = Int(timestampMs / 1000)
+      let date: Date = Date(timeIntervalSince1970: TimeInterval(timestamp))
+      return UNTimeIntervalNotificationTrigger(timeInterval: date.timeIntervalSinceNow, repeats: false)
+    case dailyNotificationTriggerType:
+      let hour: Int = (try? params.verifiedProperty(dailyNotificationTriggerHourKey, type: Int.self)) ?? 0
+      let minute: Int = (try? params.verifiedProperty(dailyNotificationTriggerMinuteKey, type: Int.self)) ?? 0
+      let dateComponents: DateComponents = DateComponents(hour: hour, minute: minute)
+      return UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)
+    case weeklyNotificationTriggerType:
+      let weekday: Int = (try? params.verifiedProperty(weeklyNotificationTriggerWeekdayKey, type: Int.self)) ?? 0
+      let hour: Int = (try? params.verifiedProperty(weeklyNotificationTriggerHourKey, type: Int.self)) ?? 0
+      let minute: Int = (try? params.verifiedProperty(weeklyNotificationTriggerMinuteKey, type: Int.self)) ?? 0
+      let dateComponents: DateComponents = DateComponents(hour: hour, minute: minute, weekday: weekday)
+      return UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)
+    case monthlyNotificationTriggerType:
+      let day: Int = (try? params.verifiedProperty(monthlyNotificationTriggerDayKey, type: Int.self)) ?? 0
+      let hour: Int = (try? params.verifiedProperty(monthlyNotificationTriggerHourKey, type: Int.self)) ?? 0
+      let minute: Int = (try? params.verifiedProperty(monthlyNotificationTriggerMinuteKey, type: Int.self)) ?? 0
+      let dateComponents: DateComponents = DateComponents(day: day, hour: hour, minute: minute)
+      return UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)
+    case yearlyNotificationTriggerType:
+      let month: Int = (try? params.verifiedProperty(yearlyNotificationTriggerMonthKey, type: Int.self)) ?? 0
+      let day: Int = (try? params.verifiedProperty(yearlyNotificationTriggerDayKey, type: Int.self)) ?? 0
+      let hour: Int = (try? params.verifiedProperty(yearlyNotificationTriggerHourKey, type: Int.self)) ?? 0
+      let minute: Int = (try? params.verifiedProperty(yearlyNotificationTriggerMinuteKey, type: Int.self)) ?? 0
+      let dateComponents: DateComponents = DateComponents(month: month, day: day, hour: hour, minute: minute)
+      return UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: true)
+    case calendarNotificationTriggerType:
+      let dateComponents: DateComponents = dateComponentsFrom(params) ?? DateComponents()
+      let repeats: Bool = ((try? params.verifiedProperty(notificationTriggerRepeatsKey, type: Bool.self) != nil ?? false) != nil)
+      return UNCalendarNotificationTrigger(dateMatching: dateComponents, repeats: repeats)
+    default:
+      return nil
+    }
+  }
+
+  func dateComponentsFrom(_ params: [AnyHashable: Any]) -> DateComponents? {
+    var dateComponents = DateComponents()
+    // TODO: Verify that DoW matches JS getDay()
+    dateComponents.calendar = Calendar.init(identifier: .iso8601)
+    if let timeZone = try? params.verifiedProperty(calendarNotificationTriggerTimezoneKey, type: String.self)
+    {
+      dateComponents.timeZone = TimeZone(identifier: timeZone)
+    }
+    dateComponentsMatchMap.keys.forEach { key in
+      let calendarComponent = dateComponentsMatchMap[key] ?? .day
+      if let value = try? params.verifiedProperty(key, type: Int.self) {
+        dateComponents.setValue(value, for: calendarComponent)
+      }
+    }
+    return dateComponents
+  }
+
+  func serializeNotificationRequests(_ requests: [UNNotificationRequest]) -> [Any] {
+    var serializedRequests: [[AnyHashable: Any]] = []
+    requests.forEach {request in
+      serializedRequests.append(EXNotificationSerializer .serializedNotificationRequest(request))
+    }
+    return serializedRequests
+  }
+
+  func buildNotificationRequest(
+    identifier: String,
+    contentInput: [AnyHashable: Any],
+    triggerInput: [AnyHashable: Any]
+  ) throws -> UNNotificationRequest? {
+    let content = try builder.content(contentInput)
+    let request = try UNNotificationRequest(identifier: identifier, content: content, trigger: triggerFromParams(triggerInput))
+    return request
+  }
+
+  public func definition() -> ModuleDefinition {
+    Name("ExpoNotificationScheduler")
+
+    AsyncFunction("getAllScheduledNotificationsAsync") { (promise: Promise) in
+
+      UNUserNotificationCenter.current().getPendingNotificationRequests { (requests: [UNNotificationRequest]) in
+        var serializedRequests: [Any] = []
+        requests.forEach {request in
+          serializedRequests.append(EXNotificationSerializer.serializedNotificationRequest(request))
+        }
+        promise.resolve(serializedRequests)
+      }
+    }
+    .runOnQueue(.main)
+
+    AsyncFunction("cancelScheduledNotificationAsync") { (identifier: String) in
+      UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: [identifier])
+    }
+
+    AsyncFunction("cancelAllScheduledNotificationsAsync") { () in
+      UNUserNotificationCenter.current().removeAllPendingNotificationRequests()
+    }
+
+    AsyncFunction("scheduleNotificationAsync") { (identifier: String, notificationSpec: [AnyHashable: Any], triggerSpec: [AnyHashable: Any], promise: Promise) in
+      guard let request = try? buildNotificationRequest(identifier: identifier, contentInput: notificationSpec, triggerInput: triggerSpec) else {
+        promise.reject("ERR_NOTIFICATIONS_FAILED_TO_SCHEDULE", "Failed to build notification request")
+        return
+      }
+      UNUserNotificationCenter.current().add(request) {error in
+        if let error = error {
+          promise.reject("ERR_NOTIFICATIONS_FAILED_TO_SCHEDULE", "Failed to schedule notification, \(error)")
+        } else {
+          promise.resolve()
+        }
+      }
+    }
+
+    AsyncFunction("getNextTriggerDateAsync") { (triggerSpec: [AnyHashable: Any], promise: Promise) in
+      guard let trigger = try? triggerFromParams(triggerSpec) else {
+        promise.reject("ERR_NOTIFICATIONS_INVALID_CALENDAR_TRIGGER", "Invalid trigger specification")
+        return
+      }
+      if trigger is UNCalendarNotificationTrigger {
+        let calendarTrigger = trigger as! UNCalendarNotificationTrigger
+        if let nextTriggerDate = calendarTrigger.nextTriggerDate() {
+          promise.resolve(nextTriggerDate.timeIntervalSince1970 * 1000)
+        } else {
+          promise.resolve(nil)
+        }
+        return
+      }
+      else if trigger is UNTimeIntervalNotificationTrigger {
+        let timeIntervalTrigger = trigger as! UNTimeIntervalNotificationTrigger
+        if let nextTriggerDate = timeIntervalTrigger.nextTriggerDate() {
+          promise.resolve(nextTriggerDate.timeIntervalSince1970 * 1000)
+        } else {
+          promise.resolve(nil)
+        }
+        return
+      }
+      else {
+        promise.reject("ERR_NOTIFICATIONS_INVALID_CALENDAR_TRIGGER", "It is not possible to get next trigger date for triggers other than calendar-based. Provided trigger resulted in \(type(of: trigger)) trigger.")
+      }
+
+    }
+  }
+}
+
diff --git a/node_modules/expo-notifications/ios/EXNotifications/Notifications/VerifiedPropertyExtension.swift b/node_modules/expo-notifications/ios/EXNotifications/Notifications/VerifiedPropertyExtension.swift
new file mode 100644
index 0000000..7596016
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/Notifications/VerifiedPropertyExtension.swift
@@ -0,0 +1,15 @@
+import ExpoModulesCore
+
+public extension [AnyHashable: Any] {
+  func verifiedProperty<T>(_ key: String, type: T.Type) throws -> T? {
+    let request = self
+    if request[key] == nil {
+      return nil
+    }
+    guard let value = request[key] as? T else {
+      let exceptionName = "Value under key \(key) is not a valid \(type)"
+      throw Exception(name: exceptionName, description: "")
+    }
+    return value
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenListener.h b/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenListener.h
deleted file mode 100644
index a5102aa..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenListener.h
+++ /dev/null
@@ -1,14 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <Foundation/Foundation.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@protocol EXPushTokenListener
-
-- (void)onDidRegisterWithDeviceToken:(NSData *)token;
-- (void)onDidFailToRegisterWithError:(NSError *)error;
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenManager.h b/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenManager.h
deleted file mode 100644
index dbf7394..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenManager.h
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <Foundation/Foundation.h>
-#import <UIKit/UIKit.h>
-#import <ExpoModulesCore/EXSingletonModule.h>
-#import <EXNotifications/EXPushTokenListener.h>
-
-NS_ASSUME_NONNULL_BEGIN
-
-@protocol EXPushTokenManager
-
-- (void)addListener:(id<EXPushTokenListener>)listener;
-- (void)removeListener:(id<EXPushTokenListener>)listener;
-
-@end
-
-@interface EXPushTokenManager : EXSingletonModule <UIApplicationDelegate, EXPushTokenManager>
-
-- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken;
-- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error;
-
-@end
-
-NS_ASSUME_NONNULL_END
diff --git a/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenManager.m b/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenManager.m
deleted file mode 100644
index 700e373..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenManager.m
+++ /dev/null
@@ -1,63 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXPushTokenManager.h>
-#import <ExpoModulesCore/EXDefines.h>
-
-@interface EXPushTokenManager ()
-
-@property (nonatomic, strong) NSPointerArray *listeners;
-
-@end
-
-@implementation EXPushTokenManager
-
-EX_REGISTER_SINGLETON_MODULE(PushTokenManager);
-
-- (instancetype)init
-{
-  if (self = [super init]) {
-    _listeners = [NSPointerArray weakObjectsPointerArray];
-  }
-  return self;
-}
-
-# pragma mark - UIApplicationDelegate
-
-- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken
-{
-  for (int i = 0; i < _listeners.count; i++) {
-    id pointer = [_listeners pointerAtIndex:i];
-    [pointer onDidRegisterWithDeviceToken:deviceToken];
-  }
-}
-
-- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error
-{
-  for (int i = 0; i < _listeners.count; i++) {
-    id pointer = [_listeners pointerAtIndex:i];
-    [pointer onDidFailToRegisterWithError:error];
-  }
-}
-
-# pragma mark - Listeners
-
-- (void)addListener:(id<EXPushTokenListener>)listener
-{
-  [_listeners addPointer:(__bridge void * _Nullable)(listener)];
-}
-
-- (void)removeListener:(id<EXPushTokenListener>)listener
-{
-  for (int i = 0; i < _listeners.count; i++) {
-    id pointer = [_listeners pointerAtIndex:i];
-    if (pointer == (__bridge void * _Nullable)(listener) || !pointer) {
-      [_listeners removePointerAtIndex:i];
-      i--;
-    }
-  }
-  // compact doesn't work, that's why we need the `|| !pointer` above
-  // http://www.openradar.me/15396578
-  [_listeners compact];
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenModule.h b/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenModule.h
deleted file mode 100644
index 93d55dc..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenModule.h
+++ /dev/null
@@ -1,9 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <ExpoModulesCore/EXExportedModule.h>
-#import <ExpoModulesCore/EXEventEmitter.h>
-#import <ExpoModulesCore/EXModuleRegistryConsumer.h>
-#import <EXNotifications/EXPushTokenListener.h>
-
-@interface EXPushTokenModule : EXExportedModule <EXEventEmitter, EXModuleRegistryConsumer, EXPushTokenListener>
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenModule.m b/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenModule.m
deleted file mode 100644
index ecedf7a..0000000
--- a/node_modules/expo-notifications/ios/EXNotifications/PushToken/EXPushTokenModule.m
+++ /dev/null
@@ -1,154 +0,0 @@
-// Copyright 2018-present 650 Industries. All rights reserved.
-
-#import <EXNotifications/EXPushTokenModule.h>
-#import <EXNotifications/EXPushTokenManager.h>
-
-#import <ExpoModulesCore/EXEventEmitterService.h>
-
-static NSString * const onDevicePushTokenEventName = @"onDevicePushToken";
-
-@interface EXPushTokenModule ()
-
-@property (nonatomic, weak) id<EXPushTokenManager> pushTokenManager;
-
-@property (nonatomic, assign) BOOL isListening;
-@property (nonatomic, assign) BOOL isBeingObserved;
-@property (nonatomic, assign) BOOL isSettlingPromise;
-
-@property (nonatomic, weak) id<EXEventEmitterService> eventEmitter;
-
-@property (nonatomic, strong) EXPromiseResolveBlock getDevicePushTokenResolver;
-@property (nonatomic, strong) EXPromiseRejectBlock getDevicePushTokenRejecter;
-
-@end
-
-@implementation EXPushTokenModule
-
-EX_EXPORT_MODULE(ExpoPushTokenManager);
-
-# pragma mark - Exported methods
-
-EX_EXPORT_METHOD_AS(getDevicePushTokenAsync,
-                    getDevicePushTokenResolving:(EXPromiseResolveBlock)resolve rejecting:(EXPromiseRejectBlock)reject)
-{
-  if (_getDevicePushTokenRejecter) {
-    reject(@"E_AWAIT_PROMISE", @"Another async call to this method is in progress. Await the first Promise.", nil);
-    return;
-  }
-
-  _getDevicePushTokenResolver = resolve;
-  _getDevicePushTokenRejecter = reject;
-  [self setIsSettlingPromise:YES];
-
-  dispatch_async(dispatch_get_main_queue(), ^{
-    [[UIApplication sharedApplication] registerForRemoteNotifications];
-  });
-}
-
-EX_EXPORT_METHOD_AS(unregisterForNotificationsAsync,
-        	    unregisterForNotificationsAsync:(EXPromiseResolveBlock)resolve reject:(EXPromiseRejectBlock)reject)
-{
-  [[UIApplication sharedApplication] unregisterForRemoteNotifications];
-  resolve(nil);
-}
-
-# pragma mark - EXModuleRegistryConsumer
-
-- (void)setModuleRegistry:(EXModuleRegistry *)moduleRegistry
-{
-  _eventEmitter = [moduleRegistry getModuleImplementingProtocol:@protocol(EXEventEmitterService)];
-  _pushTokenManager = [moduleRegistry getSingletonModuleForName:@"PushTokenManager"];
-}
-
-# pragma mark - EXEventEmitter
-
-- (NSArray<NSString *> *)supportedEvents
-{
-  return @[onDevicePushTokenEventName];
-}
-
-- (void)startObserving
-{
-  [self setIsBeingObserved:YES];
-}
-
-- (void)stopObserving
-{
-  [self setIsBeingObserved:NO];
-}
-
-- (BOOL)shouldListen
-{
-  return _isBeingObserved || _isSettlingPromise;
-}
-
-- (void)updateListeningState
-{
-  if ([self shouldListen] && !_isListening) {
-    [_pushTokenManager addListener:self];
-    _isListening = YES;
-  } else if (![self shouldListen] && _isListening) {
-    [_pushTokenManager removeListener:self];
-    _isListening = NO;
-  }
-}
-
-# pragma mark - EXPushTokenListener
-
-- (void)onDidRegisterWithDeviceToken:(NSData *)devicePushToken
-{
-  NSMutableString *stringToken = [NSMutableString string];
-  const char *bytes = [devicePushToken bytes];
-  for (int i = 0; i < [devicePushToken length]; i++) {
-    [stringToken appendFormat:@"%02.2hhx", bytes[i]];
-  }
-
-  if (_getDevicePushTokenResolver) {
-    _getDevicePushTokenResolver(stringToken);
-    [self onGetDevicePushTokenPromiseSettled];
-  }
-
-  if (_isBeingObserved) {
-    [_eventEmitter sendEventWithName:onDevicePushTokenEventName
-                                body:@{ @"devicePushToken": stringToken }];
-  }
-}
-
-- (void)onDidFailToRegisterWithError:(NSError *)error
-{
-  if (_getDevicePushTokenRejecter) {
-    NSString *message = @"Notification registration failed: ";
-
-    // A common error, localizedDescription may not be helpful.
-    if (error.code == 3000 && [NSCocoaErrorDomain isEqualToString:error.domain]) {
-      message = [message stringByAppendingString:@"\"Push Notifications\" capability hasn't been added to the app in current environment: "];
-    }
-
-    message = [message stringByAppendingFormat:@"%@", error.localizedDescription];
-    _getDevicePushTokenRejecter(@"E_REGISTRATION_FAILED", message, error);
-    [self onGetDevicePushTokenPromiseSettled];
-  }
-}
-
-- (void)onGetDevicePushTokenPromiseSettled
-{
-  _getDevicePushTokenResolver = nil;
-  _getDevicePushTokenRejecter = nil;
-  [self setIsSettlingPromise:NO];
-}
-
-# pragma mark - Internal state
-
-- (void)setIsBeingObserved:(BOOL)isBeingObserved
-{
-  _isBeingObserved = isBeingObserved;
-  [self updateListeningState];
-}
-
-- (void)setIsSettlingPromise:(BOOL)isSettlingPromise
-{
-  _isSettlingPromise = isSettlingPromise;
-  [self updateListeningState];
-}
-
-@end
diff --git a/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenAppDelegateSubscriber.swift b/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenAppDelegateSubscriber.swift
new file mode 100644
index 0000000..b16f71e
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenAppDelegateSubscriber.swift
@@ -0,0 +1,26 @@
+import ExpoModulesCore
+import Foundation
+
+public class PushTokenAppDelegateSubscriber: ExpoAppDelegateSubscriber {
+  public static let ExpoNotificationsRegistrationResult = Notification.Name("ExpoNotificationsRegistrationResult")
+
+  public func application(_ application: UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {
+    NotificationCenter.default.post(
+      name: PushTokenAppDelegateSubscriber.ExpoNotificationsRegistrationResult,
+      object: nil,
+      userInfo: ["deviceToken": dataToString(deviceToken)]
+    )
+  }
+
+  public func application(_ application: UIApplication, didFailToRegisterForRemoteNotificationsWithError error: any Error) {
+    NotificationCenter.default.post(
+      name: PushTokenAppDelegateSubscriber.ExpoNotificationsRegistrationResult,
+      object: nil,
+      userInfo: ["error": error]
+    )
+  }
+}
+
+private func dataToString(_ data: Data) -> String {
+  return data.map { String(format: "%02hhx", $0) }.joined()
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenModule.swift b/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenModule.swift
new file mode 100644
index 0000000..7b6c5b7
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/PushToken/PushTokenModule.swift
@@ -0,0 +1,60 @@
+//  Copyright © 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+let onDevicePushTokenEventName = "onDevicePushToken"
+
+public class PushTokenModule: Module {
+  var promiseNotYetResolved: Promise?
+
+  @objc
+  public func onExpoNotificationsRegistrationResult(notification: Notification) {
+    guard let userInfo = notification.userInfo else {
+      return
+    }
+    if let error = userInfo["error"] as? (any Error) {
+      promiseNotYetResolved?.reject(error)
+      promiseNotYetResolved = nil
+    } else if let deviceToken = userInfo["deviceToken"] as? String {
+      promiseNotYetResolved?.resolve(deviceToken)
+      promiseNotYetResolved = nil
+      self.sendEvent(onDevicePushTokenEventName, ["devicePushToken": deviceToken])
+    }
+  }
+
+  public func definition() -> ModuleDefinition {
+    Name("ExpoPushTokenManager")
+
+    Events([onDevicePushTokenEventName])
+
+    OnStartObserving(onDevicePushTokenEventName) {
+      NotificationCenter.default.addObserver(
+        self,
+        selector: #selector(onExpoNotificationsRegistrationResult),
+        name: PushTokenAppDelegateSubscriber.ExpoNotificationsRegistrationResult,
+        object: nil
+      )
+    }
+
+    OnStopObserving(onDevicePushTokenEventName) {
+      // swiftlint:disable:next notification_center_detachment
+      NotificationCenter.default.removeObserver(self)
+    }
+
+    AsyncFunction("getDevicePushTokenAsync") { (promise: Promise) in
+      if promiseNotYetResolved != nil {
+        promise.reject("E_AWAIT_PROMISE", "Another async call to this method is in progress. Await the first Promise.")
+      }
+      promiseNotYetResolved = promise
+      UIApplication.shared.registerForRemoteNotifications()
+    }
+    .runOnQueue(.main)
+
+    AsyncFunction("unregisterForNotificationsAsync") { () in
+      UIApplication.shared.unregisterForRemoteNotifications()
+    }
+    .runOnQueue(.main)
+  }
+}
diff --git a/node_modules/expo-notifications/ios/EXNotifications/ServerRegistration/ServerRegistrationModule.swift b/node_modules/expo-notifications/ios/EXNotifications/ServerRegistration/ServerRegistrationModule.swift
new file mode 100644
index 0000000..ec1d562
--- /dev/null
+++ b/node_modules/expo-notifications/ios/EXNotifications/ServerRegistration/ServerRegistrationModule.swift
@@ -0,0 +1,179 @@
+//  Copyright © 2024 650 Industries. All rights reserved.
+
+import ExpoModulesCore
+import UIKit
+import MachO
+
+public class ServerRegistrationModule: Module {
+  public func definition() -> ModuleDefinition {
+    Name("NotificationsServerRegistrationModule")
+
+    AsyncFunction("getInstallationIdAsync") { () -> String in
+      return try getInstallationId()
+    }
+
+    AsyncFunction("getRegistrationInfoAsync") { () -> String? in
+      return try getRegistrationInfo()
+    }
+
+    AsyncFunction("setRegistrationInfoAsync") { (registrationInfo: String) in
+      try setRegistrationInfo(registrationInfo: registrationInfo)
+    }
+  }
+
+  // MARK: - Installation ID
+
+  private func getInstallationId() throws -> String {
+    // If item in keychain, return it
+    if let installationId = try getInstallationIdFromKeychain() {
+      return installationId
+    }
+
+    // Check UserDefaults for legacy ID
+    let legacyInstallationId = getLegacyInstallationIdFromUserDefaults()
+    if let legacyInstallationId = legacyInstallationId {
+      try setInstallationIdInKeychain(legacyInstallationId)
+      // If successfully saved in keychain, remove the value from UserDefaults,
+      // and return it
+      removeLegacyInstallationIdFromUserDefaults()
+      return legacyInstallationId
+    }
+
+    // Otherwise, create a new UUID and store it in keychain
+    let newInstallationId = UUID().uuidString
+    try setInstallationIdInKeychain(newInstallationId)
+    return newInstallationId
+  }
+
+  private func getInstallationIdFromKeychain() throws -> String? {
+    try fetchStringWithQuery(installationIdGetQuery())
+  }
+
+  private func setInstallationIdInKeychain(_ installationId: String) throws {
+    try storeStringWithQueries(search: installationIdSearchQuery(), set: installationIdSetQuery(installationId))
+  }
+
+  private func getLegacyInstallationIdFromUserDefaults() -> String? {
+    return UserDefaults.standard.string(forKey: kEXDeviceInstallationUUIDLegacyKey)
+  }
+
+  private func removeLegacyInstallationIdFromUserDefaults() {
+    UserDefaults.standard.removeObject(forKey: kEXDeviceInstallationUUIDLegacyKey)
+  }
+
+  private func installationIdSearchQueryMerging(_ dictionaryToMerge: [AnyHashable: Any]) -> CFDictionary {
+    return keychainSearchQueryFor(key: kEXDeviceInstallationUUIDKey, dictionaryToMerge: dictionaryToMerge)
+  }
+
+  private func installationIdSearchQuery() -> CFDictionary {
+    return installationIdSearchQueryMerging([:])
+  }
+
+  private func installationIdGetQuery() -> CFDictionary {
+    return installationIdSearchQueryMerging([
+      kSecMatchLimit: kSecMatchLimitOne,
+      kSecReturnData: CFTrue
+    ])
+  }
+
+  private func installationIdSetQuery(_ deviceInstallationUUID: String) -> CFDictionary {
+    return installationIdSearchQueryMerging([
+      kSecValueData: dataFromString(deviceInstallationUUID),
+      kSecAttrAccessible: kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly
+    ])
+  }
+
+  // MARK: - Registration information
+
+  private func getRegistrationInfo() throws -> String? {
+    return try fetchStringWithQuery(registrationGetQuery())
+  }
+
+  private func setRegistrationInfo(registrationInfo: String) throws {
+    return try storeStringWithQueries(search: registrationSearchQuery(), set: registrationSetQuery(registrationInfo))
+  }
+
+  private func registrationSearchQueryMerging(_ dictionaryToMerge: [AnyHashable: Any]) -> CFDictionary {
+    return keychainSearchQueryFor(key: kEXRegistrationInfoKey, dictionaryToMerge: dictionaryToMerge)
+  }
+
+  private func registrationSearchQuery() -> CFDictionary {
+    return registrationSearchQueryMerging([:])
+  }
+
+  private func registrationGetQuery() -> CFDictionary {
+    return registrationSearchQueryMerging([
+      kSecMatchLimit: kSecMatchLimitOne,
+      kSecReturnData: CFTrue
+    ])
+  }
+
+  private func registrationSetQuery(_ registration: String) -> CFDictionary {
+    return registrationSearchQueryMerging([
+      kSecValueData: dataFromString(registration),
+      kSecAttrAccessible: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
+    ])
+  }
+
+  // MARK: - Generic keychain methods
+
+  private func keychainSearchQueryFor(key: String, dictionaryToMerge: [AnyHashable: Any]) -> CFDictionary {
+    let encodedKey: Data = dataFromString(key)
+    let bundleIdentifier = Bundle.main.bundleIdentifier ?? ""
+    var query: [AnyHashable: Any] = [
+      kSecClass: kSecClassGenericPassword,
+      kSecAttrService: bundleIdentifier,
+      kSecAttrGeneric: encodedKey,
+      kSecAttrAccount: encodedKey
+    ]
+    dictionaryToMerge.forEach { (key: AnyHashable, value: Any) in
+      query[key] = value
+    }
+    return query as CFDictionary
+  }
+
+  private func fetchStringWithQuery(_ query: CFDictionary) throws -> String? {
+    var item: CFTypeRef?
+    let status = SecItemCopyMatching(query, &item)
+    if status == errSecSuccess {
+      guard let existingItem = item as? Data,
+        let installationId = String.init(data: existingItem, encoding: .utf8) else {
+        return nil
+      }
+      return installationId
+    }
+    if status == errSecItemNotFound {
+      return nil
+    }
+    throw keychainException(status)
+  }
+
+  private func storeStringWithQueries(search: CFDictionary, set: CFDictionary) throws {
+    SecItemDelete(search)
+    let status = SecItemAdd(set, nil)
+    if status != errSecSuccess {
+      throw keychainException(status)
+    }
+  }
+
+  private func keychainException(_ status: OSStatus) -> Exception {
+    let statusString = SecCopyErrorMessageString(status, nil) as? String ?? "\(status)"
+    return Exception(name: "ERR_NOTIFICATIONS_KEYCHAIN_ACCESS", description: "Keychain access failed: \(statusString)", code: "\(status)")
+  }
+
+  private func dataFromString(_ input: String) -> Data {
+    if let data = input.data(using: .utf8) {
+      return data
+    }
+    // If the above fails, find the fastest encoding that can be used without loss,
+    // guaranteeing a non-null result, and a safe force-unwrapping
+    let fastEncoding = input.fastestEncoding
+    // swiftlint:disable:next force_unwrapping
+    return input.data(using: fastEncoding)!
+  }
+
+  private let kEXDeviceInstallationUUIDKey = "EXDeviceInstallationUUIDKey"
+  private let kEXDeviceInstallationUUIDLegacyKey = "EXDeviceInstallationUUIDKey"
+  private let kEXRegistrationInfoKey = "EXNotificationRegistrationInfoKey"
+  private let CFTrue = true as CFBoolean
+}
